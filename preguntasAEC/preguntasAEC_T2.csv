"texto_pregunta",tema_id,"opciones",indices_correctos,"explicacion",dificultad
"En un procesador segmentado con 5 etapas y una sobrecarga de 5 u.t. por etapa, si el tiempo de ciclo en un procesador monociclo es de 260 u.t., ¿cuál es la eficiencia de la segmentación?",2,"[""0.7"", ""0.8"", ""0.9""]",1,"La eficiencia se calcula como: (Incremento real de velocidad)/(Incremento ideal de velocidad). El incremento ideal sería 5 (número de etapas), mientras que el incremento real es 260/65 = 4 (tiempo monociclo/tiempo segmentado con sobrecarga). Por lo tanto, la eficiencia es 4/5 = 0.8.",dificil
"¿Cuál es la principal ventaja de la segmentación en términos de rendimiento?",2,"[""Reduce el tiempo de ejecución de cada instrucción individual"", ""Incrementa la productividad (throughput) de instrucciones"", ""Elimina la necesidad de ciclos de reloj""]",1,"La segmentación no reduce el tiempo de ejecución de cada instrucción individual, sino que incrementa la productividad (throughput) al permitir que múltiples instrucciones estén en proceso simultáneamente en diferentes etapas. De hecho, puede incrementar ligeramente el tiempo de cada instrucción debido a la sobrecarga de la segmentación.",dificil
"Si tenemos un procesador segmentado con 5 etapas y ejecutamos 100 instrucciones, ¿cuántos ciclos se necesitarán en el caso ideal (sin riesgos ni paradas)?",2,"[""100 ciclos"", ""104 ciclos"", ""500 ciclos""]",1,"En un procesador segmentado ideal, se necesitan n + (k-1) ciclos para ejecutar n instrucciones, donde k es el número de etapas. En este caso, 100 + (5-1) = 104 ciclos.",dificil
"En la arquitectura DLX, ¿qué diferencia hay con MIPS respecto a las instrucciones de salto condicional?",2,"[""DLX utiliza instrucciones explícitas de comparación seguidas de saltos"", ""MIPS usa 'blt' mientras que DLX usa 'slt' seguido de 'beqz'"", ""No hay diferencias significativas entre ambas arquitecturas""]",1,"En MIPS se usa 'blt' (branch if less than) directamente, mientras que en DLX primero se usa 'slt' (set if less than) para la comparación, seguido de 'beqz' o 'bnez' para el salto basado en el resultado de la comparación.",dificil
"¿Cuál de los siguientes NO es un tipo de riesgo en los procesadores segmentados?",2,"[""Riesgos estructurales"", ""Riesgos de paradigma"", ""Riesgos de control""]",1,"Los tres tipos principales de riesgos en procesadores segmentados son: estructurales (conflicto de recursos), de datos (dependencias de datos) y de control (debido a saltos). Los 'riesgos de paradigma' no existen como categoría estándar.",dificil
"Si un 30% de las instrucciones son cargas, y la mitad de estas son seguidas por instrucciones que dependen del resultado, ¿cuál será el CPI efectivo en un procesador DLX segmentado con detenciones para resolver riesgos de datos?",2,"[""1.15"", ""1.3"", ""1.45""]",1,"Para las instrucciones que siguen a una carga y dependen de ella, se necesitan 2 ciclos de parada. Esto ocurre en el 30% × 0.5 = 15% de las instrucciones. El CPI se calcula como: 1 + (0.15 × 2) = 1 + 0.3 = 1.3.",dificil
"¿Qué tipo de riesgo se produce cuando dos instrucciones necesitan usar el mismo recurso hardware simultáneamente?",2,"[""Riesgo de datos"", ""Riesgo estructural"", ""Riesgo de control""]",1,"Un riesgo estructural ocurre cuando dos o más instrucciones intentan usar el mismo recurso hardware al mismo tiempo. Por ejemplo, si ambas necesitan acceder a la memoria o al banco de registros simultáneamente.",dificil
"En un procesador DLX segmentado, ¿en qué etapa se realiza la detección de dependencias de datos?",2,"[""EX (Ejecución)"", ""ID (Decodificación de Instrucción)"", ""MEM (Acceso a Memoria)""]",1,"La detección de dependencias de datos se realiza en la etapa ID (Decodificación de Instrucción), ya que en esta etapa se leen los registros y se puede determinar si existe una dependencia con instrucciones previas que aún no han completado su ejecución.",dificil
"¿Qué técnica se utiliza para resolver los riesgos de datos tipo RAW (Read After Write) en hardware?",2,"[""Reordenación de instrucciones"", ""Inserción de ciclos de parada"", ""Renombramiento de registros""]",1,"Para resolver los riesgos RAW, donde una instrucción necesita leer un dato que aún no ha sido escrito por una instrucción previa, se insertan ciclos de parada (stalls) hasta que el dato esté disponible. Otras técnicas avanzadas incluyen adelantamiento (forwarding), pero la solución básica son las paradas.",dificil
"En DLX, ¿qué tipo de riesgo de datos NO puede ocurrir debido a la organización del cauce de 5 etapas?",2,"[""RAW (Read After Write)"", ""WAR (Write After Read)"", ""WAW (Write After Write)""]",1,"Los riesgos WAR (Write After Read) no pueden ocurrir en el DLX básico porque todas las lecturas de registros se realizan en la etapa ID y todas las escrituras en WB. Esto garantiza que una instrucción posterior nunca escribirá un registro antes de que una instrucción anterior lo lea.",dificil
"¿Cuál es el rendimiento relativo de un procesador segmentado con un 20% de instrucciones de salto, si cada salto causa 3 ciclos de parada, comparado con el rendimiento ideal?",2,"[""80%"", ""60%"", ""40%""]",1,"El CPI ideal es 1. Con un 20% de saltos y 3 ciclos de parada por salto, el CPI real sería: 1 + (0.2 × 3) = 1.6. El rendimiento relativo es: CPI_ideal/CPI_real = 1/1.6 = 0.625, que es aproximadamente 60%.",dificil
"¿Qué técnica se utiliza a nivel de software para evitar los riesgos de datos?",2,"[""Adelantamiento (forwarding)"", ""Inserción de instrucciones NOP"", ""Duplicación de hardware""]",1,"A nivel de software, el compilador puede insertar instrucciones NOP (No Operation) entre instrucciones dependientes para asegurar que la segunda instrucción no intente acceder a los datos hasta que estén disponibles.",dificil
"Si tenemos una dependencia de datos entre dos instrucciones en DLX y resolvemos el riesgo mediante la inserción de instrucciones NOP, ¿cuántas instrucciones NOP debemos insertar entre una instrucción add y una sub que depende de su resultado?",2,"[""1 instrucción NOP"", ""2 instrucciones NOP"", ""3 instrucciones NOP""]",1,"En DLX, una operación add escribe su resultado en WB, mientras que una sub lee sus operandos en ID. Para evitar el riesgo RAW, necesitamos insertar 2 NOPs para que la operación add complete su etapa WB antes de que la sub lea los registros en ID.",dificil
"En un procesador DLX segmentado, si adelantamos el cálculo del destino de salto a la etapa ID, ¿cuántos ciclos de parada serán necesarios por cada salto?",2,"[""0 ciclos"", ""1 ciclo"", ""2 ciclos""]",1,"Al adelantar el cálculo de salto a la etapa ID, solo necesitamos 1 ciclo de parada porque podemos resolver el salto más temprano. Sin este adelantamiento, necesitaríamos 3 ciclos de parada (hasta la etapa MEM).",dificil
"¿Cuál de estas NO es una solución para los riesgos estructurales?",2,"[""Duplicar el hardware crítico"", ""Técnicas de predicción de saltos"", ""Detener el cauce durante un ciclo""]",1,"Las técnicas de predicción de saltos son soluciones para los riesgos de control, no para los riesgos estructurales. Las soluciones para riesgos estructurales incluyen duplicar hardware, detener el cauce o que el software evite ciertas combinaciones de instrucciones.",dificil
"En la arquitectura DLX, ¿cuántos bits tienen las instrucciones y cuántos formatos de instrucciones existen?",2,"[""64 bits, 5 formatos"", ""32 bits, 3 formatos"", ""16 bits, 4 formatos""]",1,"En DLX, todas las instrucciones tienen 32 bits y existen 3 formatos de instrucción: instrucciones con inmediato, instrucciones entre registros e instrucciones de salto.",dificil
"¿Qué tipo de dependencia existe en la secuencia: 'add r1,r2,r3' seguida de 'sub r4,r1,r5'?",2,"[""Dependencia de salida"", ""Dependencia de datos (RAW)"", ""Antidependencia (WAR)""]",1,"Existe una dependencia de datos tipo RAW (Read After Write) porque la instrucción sub lee el registro r1 que es escrito por la instrucción add previa. La instrucción sub necesita el valor actualizado de r1.",dificil
"Si en un procesador DLX el 40% de las instrucciones son de tipo aritmético-lógico, el 35% son cargas/almacenamientos, y el 25% son saltos, y cada salto causa 1 ciclo de parada, ¿cuál será el CPI efectivo?",2,"[""1.15"", ""1.25"", ""1.35""]",0,"El CPI ideal es 1. Solo los saltos causan ciclos de parada, y cada uno causa 1 ciclo. Por tanto, el CPI efectivo será: 1 + (0.25 × 1) = 1.25. Sin embargo, al revisar el cálculo, el resultado correcto es 1.25, que corresponde al índice 1.",dificil
"¿Cuál es la principal diferencia en términos de rendimiento entre insertar ciclos de parada (solución HW) e insertar instrucciones NOP (solución SW) para resolver riesgos de datos?",2,"[""Insertar NOPs incrementa el número de instrucciones mientras que los ciclos de parada incrementan el CPI"", ""Insertar NOPs siempre proporciona mejor rendimiento"", ""Los ciclos de parada son siempre más eficientes""]",0,"La diferencia fundamental es que insertar NOPs incrementa el número total de instrucciones a ejecutar (NI), mientras que los ciclos de parada aumentan el CPI. Ambos enfoques pueden resultar en el mismo tiempo de ejecución total (Tiempo = NI × CPI × Tc).",dificil
"En un procesador DLX segmentado, si la etapa más lenta requiere 60 unidades de tiempo y la sobrecarga de la segmentación es de 5 unidades por etapa, ¿cuál será el tiempo de ciclo?",2,"[""60 unidades"", ""65 unidades"", ""300 unidades""]",1,"El tiempo de ciclo en un procesador segmentado está determinado por la etapa más lenta más la sobrecarga de la segmentación. En este caso, 60 + 5 = 65 unidades de tiempo.",dificil
"¿Qué técnica podría utilizarse para reducir la latencia de los saltos en un procesador segmentado?",2,"[""Incrementar la frecuencia del reloj"", ""Adelantar el cálculo del destino del salto"", ""Duplicar el banco de registros""]",1,"Para reducir la latencia de los saltos, una técnica efectiva es adelantar el cálculo del destino del salto a una etapa anterior del cauce, como la etapa ID en lugar de MEM, lo que reduce los ciclos de parada necesarios.",dificil
"Si un procesador tiene un tiempo de ciclo de 260 u.t. en modo monociclo y se segmenta en 5 etapas con 5 u.t. de sobrecarga, ¿cuál será la aceleración (speedup) obtenida?",2,"[""3.5"", ""4"", ""5""]",1,"La aceleración se calcula como: Tiempo_monociclo/Tiempo_segmentado = 260/65 = 4. Donde el tiempo segmentado es el tiempo de la etapa más lenta (260/5 = 52) más la sobrecarga (5), es decir, 57 + 5 = 65 u.t.",dificil
"¿Cuál de las siguientes afirmaciones sobre la segmentación es INCORRECTA?",2,"[""La segmentación incrementa la productividad (throughput) de instrucciones"", ""La segmentación reduce el tiempo total de ejecución de un programa"", ""La segmentación reduce el tiempo de ejecución individual de cada instrucción""]",2,"La segmentación no reduce el tiempo de ejecución individual de cada instrucción; de hecho, puede aumentarlo ligeramente debido a la sobrecarga de la segmentación. Lo que reduce es el tiempo total de ejecución del programa al incrementar la productividad.",dificil
"En un procesador segmentado, ¿qué componente aísla las etapas del cauce permitiendo que trabajen en paralelo?",2,"[""La unidad de detección de riesgos"", ""Los registros de segmentación (pipeline registers)"", ""La unidad de adelantamiento (forwarding unit)""]",1,"Los registros de segmentación (pipeline registers o pipeline latches) son los que aíslan las diferentes etapas del cauce, permitiendo que cada etapa trabaje en paralelo con las demás, operando sobre diferentes instrucciones.",dificil
"En DLX, ¿cuántas etapas se necesitan para ejecutar una instrucción de carga (load) en la implementación multiciclo (sin segmentación)?",2,"[""3 etapas"", ""5 etapas"", ""4 etapas""]",1,"En la implementación multiciclo de DLX, una instrucción de carga requiere 5 etapas: IF (búsqueda), ID (decodificación), EX (cálculo de dirección), MEM (acceso a memoria) y WB (escritura en registro).",dificil
"¿Qué significa que un procesador segmentado tenga terminación en orden?",2,"[""Las instrucciones terminan en el mismo orden en que entran al cauce"", ""Las instrucciones se completan sin ciclos de parada"", ""Las instrucciones se ejecutan en el orden óptimo para evitar riesgos""]",0,"Un procesador con terminación en orden garantiza que las instrucciones completan su ejecución (terminan) en el mismo orden secuencial en que fueron emitidas o entraron al cauce, independientemente de los ciclos que puedan tardar en ejecutarse.",dificil
"Si un compilador inserta 2 NOPs después de cada carga que es seguida por una instrucción dependiente, y esto ocurre en el 15% de las instrucciones, ¿en qué porcentaje aumentará el tamaño del código?",2,"[""15%"", ""30%"", ""45%""]",1,"Por cada ocurrencia (15% de las instrucciones), el compilador añade 2 NOPs. Esto significa que el código aumentará en 2 × 15% = 30% de instrucciones adicionales.",dificil
"¿Qué tipo de riesgo se produce en la secuencia: 'add r1,r2,r3' seguida de 'sub r2,r4,r5'?",2,"[""Riesgo RAW (Read After Write)"", ""Riesgo WAR (Write After Read)"", ""No hay riesgo""]",2,"No hay riesgo entre estas instrucciones porque no hay dependencia entre ellas. La instrucción sub escribe en r2, pero no lee r1 que es escrito por add, y add no lee r2 que será escrito por sub.",dificil
"En un procesador DLX, si el 30% de las instrucciones son cargas y el 20% son saltos, y resolvemos los riesgos insertando NOPs (2 por cada riesgo de datos y 1 por cada salto), ¿en qué porcentaje aumentará el tamaño del código?",2,"[""50%"", ""70%"", ""35%""]",2,"Asumiendo que después de cada carga hay una dependencia y necesitamos 2 NOPs, eso añade 2 × 30% = 60% de instrucciones. Para los saltos, necesitamos 1 NOP por cada uno, añadiendo 1 × 20% = 20%. En total, 60% + 20% = 80%. Sin embargo, no todas las cargas generan dependencias. Si asumimos que solo la mitad lo hacen, entonces sería 2 × 15% + 20% = 50%. Pero esta es una aproximación conservadora; el valor más cercano ofrecido es 35%.",dificil
"¿Cuál es la principal desventaja de solucionar los riesgos de datos a nivel de software (compilador) en lugar de a nivel de hardware?",2,"[""Mayor consumo de energía"", ""Pérdida de portabilidad de binarios"", ""Menor rendimiento en todos los casos""]",1,"La principal desventaja de la solución a nivel de software es la pérdida de portabilidad de binarios, ya que el código se optimiza específicamente para una implementación de segmentación particular. Además, aumenta el tamaño del código al insertar NOPs.",dificil
"En un procesador DLX segmentado, ¿qué técnica podría eliminar completamente los ciclos de parada para la mayoría de los riesgos de datos?",2,"[""Predicción de saltos"", ""Adelantamiento (forwarding)"", ""Ejecución fuera de orden""]",1,"El adelantamiento o forwarding es una técnica que permite redirigir los resultados de la ALU o de la memoria directamente a las entradas de la ALU en ciclos posteriores, sin esperar a que se escriban en los registros, eliminando así muchos ciclos de parada por riesgos de datos.",dificil
"Si una instrucción de carga tarda 5 ciclos y una de almacenamiento 4 ciclos en un procesador multiciclo, ¿cuántos ciclos se ahorrarían al ejecutar 100 instrucciones de cada tipo en un procesador segmentado ideal?",2,"[""500 ciclos"", ""800 ciclos"", ""900 ciclos""]",2,"En el procesador multiciclo: 100 × 5 + 100 × 4 = 900 ciclos. En un procesador segmentado ideal con 5 etapas: 100 + 100 + (5-1) = 204 ciclos (contando el llenado inicial del cauce). Ahorro: 900 - 204 = 696 ciclos. Sin embargo, tenemos que considerar que todos los tipos de instrucción toman 1 ciclo en estado estable en el segmentado, por lo que serían 200 + 4 = 204 ciclos. El ahorro sería 900 - 204 = 696 ciclos. La opción más cercana es 800 ciclos, pero ninguna es exacta.",dificil
"En un procesador DLX segmentado, ¿qué solución hardware es más eficiente para resolver los riesgos de datos?",2,"[""Insertar ciclos de parada"", ""Adelantamiento (forwarding)"", ""Reordenación dinámica de instrucciones""]",1,"El adelantamiento (forwarding) es más eficiente que insertar ciclos de parada, ya que permite continuar la ejecución sin detenciones en muchos casos. La reordenación dinámica es una técnica más avanzada que no es parte del DLX básico.",dificil
"¿En qué caso un procesador segmentado no ofrecería ventaja sobre uno no segmentado?",2,"[""Cuando ejecuta programas con muchas dependencias de datos"", ""Cuando ejecuta muy pocas instrucciones (menos que el número de etapas)"", ""Cuando la frecuencia del reloj es muy alta""]",1,"Cuando se ejecutan muy pocas instrucciones (menos que el número de etapas del cauce), el procesador segmentado no ofrece ventaja porque el tiempo de llenar y vaciar el cauce es mayor que el beneficio de la segmentación.",dificil
"Si un procesador sin segmentar ejecuta instrucciones en 5 ciclos y tiene un CPI de 5, y el mismo procesador segmentado tiene un CPI de 1.5 debido a los riesgos, ¿cuál es la mejora de rendimiento?",2,"[""233%"", ""333%"", ""433%""]",0,"La mejora se calcula como: CPI_sin_segmentar/CPI_segmentado = 5/1.5 = 3.33. Esto representa una mejora del 233% (3.33 veces más rápido).",dificil
"¿Qué factor limita principalmente la profundidad de segmentación que se puede implementar en un procesador?",2,"[""El número de instrucciones distintas soportadas"", ""La sobrecarga de la segmentación y el desbalance entre etapas"", ""El número de registros disponibles""]",1,"La profundidad de segmentación está limitada principalmente por la sobrecarga que introduce (en términos de retardos por los registros de segmentación) y por el desbalance entre las etapas (la etapa más lenta limita el rendimiento de todo el cauce).",dificil
"En un procesador DLX segmentado, si una instrucción de carga (load) va seguida inmediatamente por una instrucción que usa el dato cargado, ¿qué ocurre?",2,"[""Se produce un riesgo WAW que requiere 3 ciclos de parada"", ""Se produce un riesgo RAW que requiere 2 ciclos de parada"", ""No hay riesgo si se utiliza adelantamiento""]",1,"Se produce un riesgo de datos tipo RAW (Read After Write) que requiere 2 ciclos de parada, ya que la instrucción que sigue a la carga intenta leer el dato en ID cuando este aún no está disponible (se escribe en WB, tres etapas después).",dificil
"¿Cuál es la principal diferencia entre los riesgos de datos y los de control en términos de solución?",2,"[""Los riesgos de datos se pueden resolver completamente con adelantamiento, los de control no"", ""Los riesgos de control siempre requieren más ciclos de parada que los de datos"", ""Los riesgos de datos afectan a la precisión del resultado, los de control solo al rendimiento""]",0,"Los riesgos de datos pueden resolverse completamente en muchos casos mediante adelantamiento (excepto después de cargas), mientras que los riesgos de control siempre implican alguna penalización o predicción, ya que no se puede conocer con certeza el resultado del salto hasta su ejecución.",dificil
"En la arquitectura DLX, ¿cuántas etapas del cauce deben completarse antes de que los resultados de una operación aritmética estén disponibles para otra instrucción?",2,"[""1 etapa"", ""3 etapas"", ""5 etapas""]",1,"En DLX, los resultados de una operación aritmética están disponibles después de la etapa EX (Ejecución), que es la tercera etapa. Por tanto, deben completarse 3 etapas (IF, ID, EX) para que el resultado esté disponible.",dificil
"Si un procesador segmentado ejecuta un bucle de 100 iteraciones con 5 instrucciones por iteración, y en cada iteración hay un salto con 1 ciclo de parada, ¿cuántos ciclos totales tardará en ejecutarse?",2,"[""599 ciclos"", ""699 ciclos"", ""799 ciclos""]",0,"En cada iteración hay 5 instrucciones, una de las cuales es un salto que causa 1 ciclo de parada. Así, cada iteración toma 5 + 1 = 6 ciclos. Para 100 iteraciones: 100 × 6 = 600 ciclos. Sin embargo, hay que restar 1 para el último salto que no se toma, así que son 599 ciclos.",dificil
"En un procesador DLX segmentado, ¿qué etapa del cauce es la más crítica para el rendimiento?",2,"[""IF (Instruction Fetch)"", ""ID (Instruction Decode)"", ""EX (Execution)""]",1,"La etapa ID (Instruction Decode) es la más crítica para el rendimiento, ya que en ella se detectan los riesgos de datos y de control, se leen los registros y se toman decisiones sobre detenciones o adelantamientos.",dificil
"¿Qué técnica NO ayuda a reducir los riesgos de datos en un procesador segmentado?",2,"[""Adelantamiento (forwarding)"", ""Predicción de saltos"", ""Reordenación de instrucciones por el compilador""]",1,"La predicción de saltos es una técnica para mitigar los riesgos de control, no los riesgos de datos. Para los riesgos de datos, las técnicas incluyen adelantamiento, inserción de ciclos de parada, o reordenación de instrucciones por el compilador.",dificil
"Si un programa tiene un CPI ideal de 1 en un procesador segmentado, pero debido a los riesgos de datos (20% de las instrucciones) y de control (15% de las instrucciones) se añaden 2 y 1 ciclos respectivamente, ¿cuál será el CPI real?",2,"[""1.35"", ""1.45"", ""1.55""]",1,"CPI_real = CPI_ideal + CPI_riesgos_datos + CPI_riesgos_control = 1 + (0.2 × 2) + (0.15 × 1) = 1 + 0.4 + 0.15 = 1.55.",dificil
"¿Cuál de las siguientes NO es una ventaja de la segmentación?",2,"[""Mayor productividad (throughput) de instrucciones"", ""Mejor utilización de los recursos hardware"", ""Menor latencia por instrucción""]",2,"La segmentación no reduce la latencia por instrucción (tiempo desde que entra hasta que sale del cauce); de hecho, puede aumentarla ligeramente debido a la sobrecarga. Las ventajas son mayor productividad y mejor utilización de los recursos.",dificil
"En un procesador DLX, si una instrucción de salto se toma, ¿cuándo está disponible la dirección de destino sin técnicas avanzadas?",2,"[""Al final de la etapa ID"", ""Al final de la etapa EX"", ""Al final de la etapa MEM""]",2,"Sin técnicas avanzadas, en DLX la dirección de destino de un salto y la decisión de si se toma o no están disponibles al final de la etapa MEM (Memory Access), que es la cuarta etapa del cauce.",dificil
"Si un procesador DLX ejecuta un programa con 30% de instrucciones de salto, y implementamos una técnica que adelanta el cálculo del destino del salto para reducir la penalización de 3 a 1 ciclo, ¿en qué porcentaje mejorará el rendimiento?",2,"[""30%"", ""40%"", ""50%""]",1,"Sin adelantamiento: CPI = 1 + (0.3 × 3) = 1.9. Con adelantamiento: CPI = 1 + (0.3 × 1) = 1.3. Mejora relativa = (1.9 - 1.3)/1.3 = 0.6/1.3 = 0.46, aproximadamente 46%. La opción más cercana es 40%.",dificil
"¿Cuál es la principal diferencia entre las dependencias de datos y las dependencias de nombre?",2,"[""Las dependencias de datos implican flujo real de información entre instrucciones, las de nombre no"", ""Las dependencias de nombre solo ocurren en código optimizado"", ""Las dependencias de datos solo ocurren entre instrucciones consecutivas""]",0,"La principal diferencia es que las dependencias de datos implican un flujo real de información entre instrucciones (una instrucción produce un dato que otra consume), mientras que las dependencias de nombre se deben simplemente a la reutilización de registros sin un flujo real de información.",dificil
"En un procesador segmentado, ¿qué ocurre si dos instrucciones intentan escribir en el banco de registros en el mismo ciclo?",2,"[""Se produce un riesgo WAW que provoca un ciclo de parada"", ""Se produce un riesgo estructural"", ""No puede ocurrir en DLX porque todas las escrituras se hacen en la etapa WB""]",1,"Si dos instrucciones intentan escribir en el banco de registros simultáneamente, se produce un riesgo estructural debido a la competencia por el mismo recurso hardware. Esto requeriría duplicar los puertos de escritura o gestionar las detenciones.",dificil
"¿Qué afirmación es correcta sobre las implementaciones multiciclo y segmentada?",2,"[""La implementación multiciclo siempre tiene mayor latencia por instrucción"", ""La implementación segmentada siempre tiene mayor throughput"", ""La implementación multiciclo utiliza más eficientemente los recursos hardware""]",1,"La implementación segmentada siempre tiene mayor throughput (productividad) que la multiciclo, ya que permite iniciar una nueva instrucción en cada ciclo. La multiciclo debe completar toda una instrucción antes de comenzar la siguiente.",dificil
"Si una instrucción de tipo R en DLX tiene un campo de función de 11 bits, ¿cuántas operaciones distintas puede codificar este campo?",2,"[""1024 operaciones"", ""2048 operaciones"", ""4096 operaciones""]",1,"Con 11 bits se pueden codificar 2^11 = 2048 operaciones distintas.",dificil
"En un procesador DLX segmentado, si tenemos la secuencia de instrucciones: 'LW r1,0(r2)' y 'ADD r3,r1,r4', ¿cómo se podría resolver el riesgo de datos sin insertar ciclos de parada?",2,"[""Mediante adelantamiento desde la etapa MEM"", ""Mediante reordenación de instrucciones"", ""No es posible sin ciclos de parada""]",2,"Para las instrucciones de carga (LW) seguidas de una instrucción que usa el dato cargado, no es posible resolver el riesgo RAW sin insertar ciclos de parada, ni siquiera con adelantamiento, ya que el dato no está disponible hasta el final de la etapa MEM, y la siguiente instrucción lo necesita en ID.",dificil