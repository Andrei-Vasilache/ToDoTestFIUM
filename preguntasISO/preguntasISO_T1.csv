texto_pregunta,tema_id,opciones,indices_correctos,explicacion
"En un sistema de procesamiento por lotes de segunda generación, ¿cuál era la principal desventaja del mecanismo de operación en línea (on-line) frente a la operación fuera de línea (off-line)?",1,"[""La operación en línea requería que los programadores tuvieran más conocimientos técnicos que la operación fuera de línea"", ""En la operación en línea, la CPU permanecía ociosa durante las operaciones de E/S, desaprovechando un recurso caro""]",1,"Como se explica en la sección 1.3.2, en la operación en línea la CPU interactuaba directamente con los dispositivos de E/S lentos como el lector de tarjetas o la impresora, lo que provocaba que la CPU tuviera que esperar a que finalizara cada operación de E/S. Esta espera generaba períodos en los que la CPU se encontraba ociosa y, por tanto, infrautilizada, algo poco deseable dado que era un recurso muy caro. La operación fuera de línea solucionaba este problema haciendo que la CPU interactuara con dispositivos más rápidos como las cintas magnéticas, permitiendo un mejor aprovechamiento del recurso más costoso (la CPU)."
"¿Cuál de los siguientes mecanismos hardware NO es necesario para garantizar la protección del sistema operativo?",1,"[""Interrupciones periódicas"", ""Memoria virtual""]",1,"Según la sección 1.2, los tres mecanismos hardware básicos necesarios para garantizar la protección del sistema operativo son: (1) modos de ejecución del procesador (modo núcleo y modo usuario), (2) protección de la memoria, y (3) interrupciones periódicas. La memoria virtual, aunque es un componente importante en sistemas operativos modernos, no es uno de los tres mecanismos básicos de protección mencionados en el texto. La memoria virtual es una técnica para gestionar la memoria que permite ejecutar programas más grandes que la memoria física disponible, pero no es imprescindible para proteger al sistema operativo del resto de programas."
"¿Qué diferencia fundamental hay entre un sistema operativo monolítico y uno basado en micronúcleo en cuanto a la ejecución de los componentes del sistema?",1,"[""En un sistema monolítico, todos los componentes se ejecutan en modo núcleo, mientras que en un sistema de micronúcleo, muchos servicios se ejecutan como procesos en modo usuario"", ""En un sistema monolítico, cada componente tiene su propio espacio de direcciones, mientras que en un sistema de micronúcleo todos comparten el mismo espacio""]",0,"Como se describe en la sección 1.6.3, en un sistema basado en micronúcleo, la mayoría de las funciones del sistema operativo se implementan en procesos de usuario (servidores), que se ejecutan en modo usuario, manteniendo un núcleo mínimo. En cambio, en un sistema monolítico (sección 1.6.1), todos los componentes del sistema operativo forman parte del núcleo y se ejecutan en modo núcleo, sin distinción. Esta es una diferencia arquitectónica fundamental que afecta a la seguridad, mantenibilidad y robustez del sistema."
"En el contexto de la protección en sistemas operativos, ¿por qué los tres mecanismos de protección (modos de ejecución, protección de memoria e interrupciones periódicas) deben funcionar de forma conjunta?",1,"[""Porque cada mecanismo protege contra un tipo diferente de ataque externo al sistema"", ""Porque si falta alguno de los tres, los demás podrían ser deshabilitados por un programa malicioso""]",1,"Como se explica en la sección 1.2, la protección solo funciona si los tres mecanismos mencionados existen y se usan de forma conjunta. Por ejemplo, si existen las interrupciones periódicas y la protección de memoria, pero el procesador no dispone de dos modos de funcionamiento, cualquier programa podría cambiar la configuración tanto de la protección de memoria como de las interrupciones, haciendo que estas dejen de desempeñar su función. Es decir, la ausencia de uno de los mecanismos permitiría a un programa malicioso deshabilitar los otros mecanismos de protección."
"¿Cuál es la principal diferencia entre los sistemas operativos de red y los sistemas operativos distribuidos?",1,"[""Los sistemas operativos de red no ofrecen servicios de comunicación entre máquinas mientras que los distribuidos sí"", ""En los sistemas operativos de red los usuarios son conscientes de la existencia de múltiples computadoras, mientras que en los distribuidos se ofrece una imagen única del sistema""]",1,"Según la sección 1.4.3, la principal diferencia es que en los sistemas operativos de red (sección 1.4.2), los usuarios son conscientes de la existencia de varios ordenadores conectados mediante una red, mientras que los sistemas operativos distribuidos son vistos por los usuarios como un sistema tradicional, con un único computador y un único sistema operativo, ofreciendo así una imagen única del sistema. Esta transparencia de localización hace que el usuario no sea consciente de dónde se ejecutan sus programas ni dónde se encuentran sus ficheros."
"En el modelo cliente-servidor con micronúcleo, ¿cómo se resuelve el problema de que los servidores ejecutándose en modo usuario necesiten realizar operaciones privilegiadas?",1,"[""No es posible resolverlo; los servidores que necesitan realizar operaciones privilegiadas deben ejecutarse siempre en modo núcleo"", ""Mediante mensajes especiales enviados por los servidores al micronúcleo, que ejecuta las operaciones privilegiadas tras verificar los permisos""]",1,"Como se explica en la sección 1.6.3, existen dos soluciones principales para este problema: incluir el servidor en el núcleo (lo que elimina la ventaja de protección) o utilizar mensajes especiales que captura el micronúcleo para procesarlos él mismo. La segunda opción es preferible porque mantiene todas las ventajas de ejecutar los servidores en modo usuario. En este caso, el micronúcleo no solo realizará las operaciones privilegiadas en nombre de los servidores, sino que también verificará si el servidor que envía una solicitud tiene permiso para hacerlo."
"¿Qué innovación fundamental introducida en los sistemas de la segunda generación (1955-1965) permitió a los programadores dejar de preocuparse por el tipo específico de dispositivo de E/S que utilizaban?",1,"[""El sistema de interrupciones"", ""La independencia de dispositivo de E/S""]",1,"Como se menciona en la sección 1.3.2, la operación fuera de línea dio lugar a la independencia de dispositivo de E/S. Esta idea permitía que los programas se escribieran para usar dispositivos lógicos de E/S creados por el sistema operativo, siendo este el que hacía corresponder los dispositivos lógicos con los físicos. Gracias a esto, los programadores no necesitaban conocer si los datos se leían de una tarjeta o una cinta, o si se escribían en una impresora o en una cinta, ya que el acceso a los dispositivos lógicos siempre se hacía de la misma manera."
"¿Cuál de las siguientes afirmaciones acerca de los sistemas operativos de tiempo real es FALSA?",1,"[""Los sistemas de tiempo real rigurosos pueden permitir ocasionalmente el incumplimiento de plazos si el sistema está sobrecargado"", ""El parámetro clave en los sistemas de tiempo real son las restricciones temporales""]",0,"Según la sección 1.4.4, los sistemas operativos de tiempo real rigurosos requieren que una acción se realice necesariamente en cierto momento o intervalo, y de no cumplirse esta restricción, se pueden producir situaciones críticas que pueden poner el sistema en peligro. Son los sistemas de tiempo real no rigurosos los que pueden aceptar no cumplir ocasionalmente un plazo. Por tanto, la primera opción es falsa, ya que confunde las características de los sistemas rigurosos con las de los no rigurosos."
"¿Qué implica técnicamente la "transparencia de localización" en un sistema operativo distribuido?",1,"[""El cifrado de las comunicaciones para que no sean visibles para usuarios no autorizados"", ""Que el usuario no es consciente de dónde se ejecutan sus programas ni dónde se encuentran sus ficheros""]",1,"Como se indica en la sección 1.4.3 la transparencia de localización en sistemas operativos distribuidos significa que el usuario no es consciente del lugar donde se ejecutan sus programas ni dónde se encuentran sus ficheros. Esto es parte del concepto de "imagen única del sistema" que ofrecen estos sistemas operativos haciendo que todo el sistema distribuido aparezca ante el usuario como un único sistema tradicional."
"¿Cuál era la principal ventaja que ofrecía el mecanismo de spooler sobre el uso simple de buffers en los sistemas de segunda generación?",1,"[""Los spoolers permitían la superposición de la E/S de unos programas con el cómputo de otros, mientras que los buffers solo permitían solapar E/S y cómputo dentro del mismo programa"", ""Los spoolers consumían menos memoria que los buffers, permitiendo ejecutar programas más grandes""]",0,"Según la sección 1.3.2, la diferencia fundamental entre buffers y spoolers es que los buffers permitían que la E/S de un programa se realizara de forma simultánea con el cómputo del mismo programa. En cambio, el mecanismo de spooler permitía la superposición de la E/S de unos programas con el cómputo de otro, obteniendo un beneficio similar al de las operaciones fuera de línea. Esto era posible porque el spooler almacenaba temporalmente en disco los datos de entrada/salida, permitiendo que un programa pudiera continuar su procesamiento mientras otro realizaba operaciones de E/S."
"En un sistema operativo por capas, ¿qué ocurre cuando una capa necesita acceder a funcionalidades que están implementadas en capas no adyacentes?",1,"[""La capa debe implementar su propia versión de esas funcionalidades, ya que no puede acceder directamente a capas no adyacentes"", ""La capa solo puede acceder a esas funcionalidades a través de la interfaz proporcionada por la capa inmediatamente inferior""]",1,"Según la sección 1.6.2, en el diseño modular por capas, cada capa solo utiliza las funciones y servicios de la capa inmediatamente inferior. Esto significa que si una capa necesita acceder a una funcionalidad implementada en una capa no adyacente (más inferior), debe hacerlo a través de la interfaz que proporciona su capa inmediatamente inferior, y así sucesivamente hasta llegar a la capa que implementa dicha funcionalidad. Esta restricción es parte del diseño que aumenta la modularidad, pero también es una de las dificultades de este enfoque, ya que pueden surgir problemas de dependencias entre capas."
"¿Qué característica fundamental distingue a los sistemas operativos de tiempo compartido de los sistemas con multiprogramación básica?",1,"[""Los sistemas de tiempo compartido implementan un cambio rápido entre tareas para dar sensación de interactividad a múltiples usuarios"", ""Los sistemas de tiempo compartido solo permiten un número limitado de programas en memoria, mientras que la multiprogramación no tiene esta limitación""]",0,"Como se describe en la sección 1.3.3, el tiempo compartido o multitarea es una variante de la multiprogramación que consiste en realizar un cambio rápido entre tareas, lo que permite que cada usuario pueda interactuar con el programa que está ejecutando y tener la sensación de que él es el único usuario de la máquina. Este enfoque en la interactividad y la rápida respuesta a múltiples usuarios es lo que distingue el tiempo compartido de la multiprogramación básica, que simplemente busca mantener la CPU ocupada alternando entre programas cuando estos tienen que esperar por operaciones de E/S."
"¿En qué consiste principalmente la memoria extendida o virtual desde la perspectiva de sistema operativo como "máquina virtual"?",1,"[""En permitir la asignación de más memoria a los programas de la que físicamente existe en el sistema"", ""En mostrar a los programas que la cantidad de memoria disponible es menor de la que realmente existe para reservar parte de ella al sistema operativo""]",0,"Según la sección 1.1, el sistema operativo como máquina virtual o extendida es un programa que oculta el funcionamiento del hardware y presenta una interfaz sencilla y amigable. Entre otras cosas, el sistema añade nuevos componentes y funcionalidades que el hardware por sí mismo no proporciona. La memoria virtual es una abstracción que permite a los programas utilizar más memoria de la que físicamente existe en el sistema, mediante técnicas como la paginación o segmentación, creando la ilusión de un espacio de memoria más grande."
"¿Cuál es la diferencia conceptual más relevante entre un proceso y un programa?",1,"[""Un proceso es una entidad activa con un contador de programa que indica la siguiente instrucción a ejecutar, mientras que un programa es una entidad pasiva con código y datos almacenados en disco"", ""Un proceso solo puede ejecutar código de sistema, mientras que un programa solo puede ejecutar código de usuario""]",0,"Como se define en la sección 1.5.1, un proceso es un programa en ejecución, es decir, una entidad activa que tiene, entre otras cosas, un contador de programa que indica cuál es la siguiente instrucción a ejecutar. Un programa, en cambio, es una entidad pasiva, pues es el contenido estático (código y datos) de un fichero almacenado en disco. Esta distinción fundamental entre la naturaleza activa de un proceso frente a la pasiva de un programa es clave para entender la administración de procesos en los sistemas operativos."
"En los sistemas operativos actuales, ¿cómo se resuelve el problema de que los programas de usuario necesiten realizar operaciones de E/S que requieren instrucciones privilegiadas?",1,"[""Los programas de usuario reciben temporalmente privilegios de modo núcleo para ejecutar esas instrucciones"", ""Los programas de usuario realizan llamadas al sistema que se ejecutan en modo núcleo""]",1,"Como se explica en la sección 1.2, cuando un programa de usuario necesita realizar operaciones de E/S (que requieren instrucciones privilegiadas), debe pedirle al sistema operativo que haga esa operación por él mediante una llamada al sistema. Esta instrucción produce una acción similar a la de una interrupción que es tratada por el sistema operativo en modo núcleo. Así, el programa nunca ejecuta directamente las instrucciones privilegiadas, sino que solicita al sistema operativo que las ejecute en su nombre."
"¿Cómo solucionan los sistemas operativos modernos el problema de que un programa pueda entrar en un bucle infinito y monopolizar la CPU?",1,"[""Mediante interrupciones periódicas generadas por hardware que devuelven el control al sistema operativo"", ""Mediante la comprobación en tiempo de compilación de bucles que no tengan condición de salida""]",0,"Como se menciona en la sección 1.2, para que un programa no se haga con el control de la CPU, es necesario que el hardware disponga de algún reloj o dispositivo similar que produzca interrupciones periódicas. Estas interrupciones permiten al sistema operativo hacerse con el control de la máquina cada cierto tiempo. Al tomar el control, el sistema operativo puede asignar la CPU a otro programa y así evitar que el sistema se bloquee debido a un programa que ha entrado en un bucle infinito."
"En el contexto de la evolución histórica de los sistemas operativos, ¿qué problema fundamental resolvió la multiprogramación?",1,"[""El alto costo de los primeros ordenadores al permitir que múltiples usuarios compartieran el mismo hardware"", ""La infrautilización de la CPU debido a tiempos de espera por operaciones de E/S, permitiendo que otro programa use la CPU mientras uno espera""]",1,"Según la sección 1.3.3, la multiprogramación consiste en tener varios programas en memoria. Cuando un programa que usa la CPU tiene que esperar (por ejemplo, a que termine una operación de E/S), se pasa a otro programa que esté listo para ejecutarse. De esta manera, se consigue la superposición de la E/S de unos programas con el uso de la CPU de otros, solucionando así el problema de la infrautilización de la CPU durante las operaciones de E/S, que era una limitación importante en los sistemas de generaciones anteriores."
"¿Por qué los sistemas operativos distribuidos ofrecen mejor tolerancia a fallos que los sistemas centralizados?",1,"[""Porque utilizan algoritmos de detección y corrección de errores más sofisticados"", ""Porque si una máquina falla, el resto puede seguir realizando el trabajo""]",1,"Como se menciona en la sección 1.4.3, una de las razones para la existencia de sistemas distribuidos es la confiabilidad o tolerancia a fallos: si una máquina falla, el resto seguirá realizando todo el trabajo. Esto se debe a la naturaleza distribuida del sistema, donde los recursos y las capacidades de procesamiento están repartidos entre múltiples máquinas, permitiendo que el sistema como un todo siga funcionando incluso si algunos de sus componentes fallan."
"¿Qué método de paso de parámetros en llamadas al sistema es más adecuado cuando hay más parámetros que registros disponibles en el procesador?",1,"[""Paso de parámetros en registros"", ""Paso de parámetros en un bloque de memoria""]",1,"Según la sección 1.5.3, existen tres formas generales de pasar parámetros al sistema operativo durante una llamada al sistema: en registros, en un bloque de memoria, o en la pila. El paso en registros es el más sencillo, pero tiene la limitación de que puede haber más parámetros que registros disponibles. En ese caso, el paso de parámetros mediante un bloque de memoria (donde los parámetros se almacenan en memoria y se pasa la dirección del bloque en un registro) o mediante la pila serían opciones más adecuadas."
"En el contexto de la estructura de un sistema operativo, ¿qué ventaja principal ofrece un sistema con capas sobre un sistema monolítico?",1,"[""Mayor velocidad de ejecución al reducir las llamadas entre componentes"", ""Mayor facilidad para depurar y modificar componentes individuales sin afectar al resto del sistema""]",1,"Como se explica en la sección 1.6.2, la principal ventaja de la estructura por capas es la modularidad. Esto facilita la depuración y verificación del sistema (una vez implementada y verificada una capa, se asciende a la siguiente) y permite modificar una capa en cualquier momento sin tener que hacer cambios en otras, siempre que no se altere su interfaz. En cambio, en los sistemas monolíticos (sección 1.6.1) no existe ocultación, ya que todo procedimiento es visible a los demás, lo que dificulta la modificación y depuración de componentes individuales."
"¿Cuál es la principal limitación de los sistemas operativos por capas que ha llevado a que se prefieran sistemas con pocas capas pero más funcionalidad en cada una?",1,"[""El costo computacional de las llamadas entre capas reduce significativamente el rendimiento"", ""La dificultad para determinar dónde colocar ciertas funciones debido a dependencias entre capas""]",1,"Como se menciona en la sección 1.6.2, la mayor dificultad del enfoque por capas es el propio diseño de las mismas (número de capas, funciones de cada una, interfaz exportada, etc.), ya que cada capa solo puede utilizar los servicios de las capas inferiores. Esto hace que surjan problemas de dependencias entre capas y que, a veces, sea difícil saber dónde colocar una determinada función. Por esta razón, en la actualidad se opta por tener pocas capas, pero con más funcionalidad en cada una, lo que simplifica el diseño manteniendo cierto grado de modularidad."
"¿Qué problema fundamental de los sistemas operativos monolíticos intenta resolver el modelo cliente-servidor con micronúcleo?",1,"[""La falta de flexibilidad para adaptarse a diferentes arquitecturas hardware"", ""La vulnerabilidad del sistema completo ante fallos en cualquier componente""]",1,"Como se explica en la sección 1.6.3, una ventaja clave del modelo cliente-servidor con micronúcleo es que los servidores se ejecutan en modo usuario, lo que significa que un fallo en uno de ellos (por ejemplo, en el sistema de ficheros) no afectaría a todo el sistema. Incluso sería posible reiniciar el proceso servidor y hacer que el sistema se recupere de la caída. En contraste, en un sistema monolítico, donde todos los componentes forman parte del núcleo, un fallo en cualquier parte podría comprometer la estabilidad de todo el sistema operativo."
"¿Cuál fue la innovación más significativa de la tercera generación de sistemas operativos (1965-1980) que cambió fundamentalmente cómo los usuarios interactuaban con los computadores?",1,"[""La aparición de los sistemas operativos de tiempo compartido que devolvieron la interactividad a los usuarios"", ""La introducción de los sistemas de procesamiento por lotes que aumentaron la eficiencia""]",0,"Como se describe en la sección 1.3.3, en la primera generación los ordenadores eran sistemas interactivos pero con un coste muy elevado, lo que llevó a la adopción de técnicas como el procesamiento por lotes en la segunda generación para aumentar el rendimiento. Sin embargo, estas técnicas hicieron que el programador perdiera la interactividad. Con los sistemas de tiempo compartido de la tercera generación, los usuarios recuperaron de nuevo la interactividad a un coste razonable, lo que supuso un cambio fundamental en la forma en que los usuarios interactuaban con los computadores."
"En relación con la protección del sistema operativo, ¿por qué se necesita un mecanismo de protección de memoria?",1,"[""Para evitar que un programa acceda a zonas de memoria RAM que no le pertenecen, garantizando así la integridad del sistema operativo y otros programas"", ""Para gestionar eficientemente la memoria disponible y evitar desperdiciar espacio""]",0,"Como se explica en la sección 1.2, el hardware debe tener algún mecanismo que impida que un programa acceda a zonas de memoria RAM que no le pertenecen. De esta forma, se evita que un programa pueda leer o modificar el código, los datos o la pila de otros programas y, sobre todo, del sistema operativo. Si no se protegiera la RAM, un programa podría modificar el vector de interrupciones, las rutinas de servicio de interrupción del sistema operativo u otras partes del sistema operativo, y hacerse con el control de la máquina, comprometiendo su integridad."
"¿Qué característica fundamental distingue al sistema operativo como "controlador de recursos" frente a su visión como "máquina extendida"?",1,"[""Como controlador de recursos, el sistema operativo se enfoca en la gestión eficiente y segura de los recursos entre múltiples programas y usuarios"", ""Como controlador de recursos, el sistema operativo se centra en ocultar la complejidad del hardware a los programadores""]",0,"Según la sección 1.1 desde el punto de vista de "máquina extendida o virtual" el sistema operativo es un programa que oculta el funcionamiento del hardware al programador y presenta una interfaz sencilla y amigable. En cambio desde el punto de vista de "controlador de recursos" el sistema operativo es un programa que controla todas las piezas de un sistema complejo y proporciona una asignación ordenada y controlada de los recursos (procesadores memoria dispositivos de E/S etc.) entre los distintos programas que compiten por ellos. Por tanto la distinción fundamental está en el enfoque: facilitar la programación (máquina extendida) versus gestionar recursos compartidos (controlador de recursos)."
"En los sistemas operativos de tiempo real rigurosos, ¿qué ocurre si no se cumple una restricción temporal?",1,"[""El sistema realiza automáticamente un reinicio para recuperarse del error"", ""Se pueden producir situaciones críticas que pueden poner el sistema en peligro""]",1,"Como se indica en la sección 1.4.4, en los sistemas operativos de tiempo real rigurosos, una acción se debe realizar necesariamente en cierto momento o intervalo. De no cumplirse esta restricción, se pueden producir situaciones críticas que pueden poner el sistema en peligro. Esto contrasta con los sistemas de tiempo real no rigurosos, donde es aceptable no cumplir de vez en cuando un plazo, siempre y cuando el comportamiento general del sistema se ajuste a ciertos parámetros."
"¿Qué problema fundamental intentaba resolver el mecanismo de buffer en los sistemas de segunda generación?",1,"[""La falta de memoria principal para ejecutar programas grandes"", ""El desequilibrio entre la velocidad de la CPU y los dispositivos de E/S""]",1,"Como se explica en la sección 1.3.2, un buffer es una zona de memoria principal que se utiliza para el almacenamiento temporal de datos. Con los buffers, los datos no pasan directamente del dispositivo de E/S a la CPU o viceversa, sino a través de un buffer intermedio. Esto permite que mientras la CPU procesa los datos del buffer, el dispositivo de E/S pueda estar leyendo la siguiente porción de datos, logrando así que la E/S del programa se realice de forma simultánea con su cómputo. El objetivo principal es reducir el tiempo que la CPU pasa esperando a los dispositivos de E/S, que son mucho más lentos."
"¿Qué ventaja fundamental ofrece el modelo cliente-servidor en un sistema distribuido comparado con un sistema centralizado?",1,"[""Mayor rendimiento computacional al distribuir las tareas entre múltiples procesadores"", ""Transparencia en la comunicación, ya que un cliente se comunica con el servidor mediante mensajes independientemente de su ubicación física""]",1,"Como se describe en la sección 1.6.3, una ventaja del modelo cliente-servidor es su capacidad de adaptación a los sistemas distribuidos. Un cliente se comunica con el servidor por medio de mensajes, sin importar si ambos están en la misma o en diferentes máquinas; en lo que respecta al cliente, ocurre lo mismo en ambos casos: se envía una solicitud y se recibe una respuesta. Esta transparencia en la comunicación permite construir sistemas distribuidos que pueden aprovechar recursos en diferentes máquinas sin que los clientes tengan que preocuparse por la ubicación física de los servidores."
"¿Cuál es la diferencia clave entre los sistemas operativos de tarjetas inteligentes y los sistemas operativos de propósito general en términos de funcionalidad?",1,"[""Los sistemas de tarjetas inteligentes utilizan arquitecturas distribuidas mientras que los de propósito general son centralizados"", ""Los sistemas de tarjetas inteligentes solo pueden realizar unas pocas funciones debido a limitaciones de potencia y memoria""]",1,"Según la sección 1.4.5, los sistemas operativos para tarjetas inteligentes, debido a las propias características de estas tarjetas que tienen grandes limitaciones de potencia y memoria, solo son capaces de realizar unas pocas funciones. Habitualmente disponen de una máquina virtual de Java que se encarga de ejecutar los applets cargados en la tarjeta. Esto contrasta con los sistemas operativos de propósito general (sección 1.4.1), que están diseñados para realizar una gran variedad de tareas computacionales en entornos de diferente naturaleza, caracterizándose por su flexibilidad y capacidad de adaptación."
"En el contexto de la administración de ficheros ¿qué significa que el sistema operativo presente "una perspectiva lógica uniforme del almacenamiento de información"?",1,"[""Que todos los archivos deben tener el mismo tamaño para simplificar su gestión"", ""Que el sistema ofrece una abstracción (ficheros) que oculta las características específicas de los dispositivos de almacenamiento subyacentes""]",1,"Como se explica en la sección 1.5.1, el sistema operativo ofrece una perspectiva lógica uniforme del almacenamiento de información, abstrayendo las propiedades particulares de los dispositivos subyacentes. Para conseguir esto, define una unidad de almacenamiento lógico que es el fichero. Gracias a ello, es posible acceder (leer y escribir) cómodamente a la información existente en los dispositivos físicos a través de los ficheros definidos sobre ellos, sin necesidad de conocer las características específicas de cada dispositivo de almacenamiento."
"¿Qué problema fundamental resuelve el paso de parámetros a través de un bloque de memoria en las llamadas al sistema?",1,"[""Evita que los programas de usuario puedan acceder directamente a la memoria del sistema operativo"", ""Permite pasar una cantidad arbitraria de parámetros sin estar limitado por el número de registros disponibles""]",1,"Como se menciona en la sección 1.5.3, el paso de parámetros en registros es sencillo, pero tiene la limitación de que puede haber más parámetros que registros disponibles. El paso de parámetros en un bloque de memoria resuelve este problema al permitir almacenar los parámetros en un bloque en la memoria y pasar únicamente la dirección del bloque como parámetro en un registro. De esta forma, se puede pasar una cantidad arbitraria de parámetros independientemente del número de registros disponibles en el procesador."
"¿Por qué en los sistemas operativos modernos las llamadas al sistema suelen estar encapsuladas por funciones de bibliotecas de lenguajes de alto nivel?",1,"[""Porque las llamadas al sistema nativas no pueden acceder a ciertos recursos del hardware"", ""Para ocultar la complejidad de las llamadas al sistema y proporcionar una interfaz más sencilla a los programadores""]",1,"Como se explica en la sección 1.5.3, las bibliotecas de los lenguajes de alto nivel suelen contener procedimientos que ocultan las llamadas al sistema, proporcionando así una interfaz mucho más sencilla que la proporcionada por las llamadas al sistema en lenguaje ensamblador. Por ejemplo, printf es una función de C que construye una cadena según el formato y los parámetros que recibe, efectúa las llamadas al sistema necesarias para mostrar la cadena por pantalla, comprueba los posibles errores y devuelve el control al programa de usuario. De esta forma, se oculta la complejidad de las llamadas al sistema nativas."
"En un sistema operativo de quinta generación, ¿qué innovación tecnológica ha sido más determinante para su evolución?",1,"[""Los algoritmos de planificación de procesos más eficientes"", ""La explosión del uso de Internet y la proliferación de dispositivos móviles""]",1,"Según la sección 1.3.5, lo que caracteriza a la quinta generación (1995-actualidad) es la explosión del uso de Internet (y de sus servicios, como el cloud computing) y la proliferación de dispositivos móviles de todo tipo, especialmente los llamados teléfonos inteligentes o smartphones. Estas innovaciones tecnológicas han sido determinantes para la evolución de los sistemas operativos de esta generación, como Windows, Linux, Apple macOS, Android e iOS, que han tenido que adaptarse a nuevos paradigmas de conexión, movilidad y computación en la nube."
"¿Qué diferencia fundamental hay entre un sistema operativo monolítico y uno con estructura por capas en términos de organización del código?",1,"[""En el sistema monolítico no hay ocultación (todo procedimiento es visible a los demás), mientras que en el de capas cada capa oculta detalles a las capas superiores"", ""El sistema monolítico no permite la modularización del código mientras que el sistema por capas sí la permite""]",0,"Como se explica en las secciones 1.6.1 y 1.6.2, una diferencia fundamental entre ambos tipos de sistemas es que en los sistemas monolíticos no existe ocultación, ya que todo procedimiento es visible a los demás. En cambio, en los sistemas por capas, cada capa oculta los detalles de bajo nivel a las capas superiores, permitiendo modificar una capa en cualquier momento sin tener que hacer cambios en otras, siempre que no se altere su interfaz. Esta diferencia en la visibilidad y encapsulación del código es una característica clave que distingue ambos enfoques."
"¿Qué mecanismo de protección hardware permite que un programa de usuario solicite servicios al sistema operativo sin comprometer la seguridad?",1,"[""La memoria virtual"", ""Los modos de ejecución del procesador y las llamadas al sistema""]",1,"Como se explica en la sección 1.2, el procesador debe disponer de al menos dos modos de ejecución: modo núcleo y modo usuario. Los programas de usuario se ejecutan en modo usuario, donde no pueden ejecutar ciertas instrucciones privilegiadas como las de E/S. Para realizar estas operaciones, deben utilizar una instrucción especial conocida como llamada al sistema, que produce una acción similar a una interrupción y transfiere el control al sistema operativo en modo núcleo. Este mecanismo permite que los programas de usuario soliciten servicios al sistema operativo de forma segura, sin comprometer la integridad del sistema."
"¿Qué ventaja fundamental proporcionaron los circuitos integrados en la tercera generación de sistemas operativos (1965-1980)?",1,"[""Permitieron que los ordenadores fueran más pequeños y fiables, tendencia que continuaría en generaciones posteriores"", ""Aumentaron drásticamente la capacidad de almacenamiento secundario disponible para los sistemas""]",0,"Como se menciona en la sección 1.3.3, la aparición de los circuitos integrados en la tercera generación hizo que los ordenadores se volvieran más pequeños y fiables, una tendencia que seguiría también en las siguientes generaciones. Esta reducción de tamaño y aumento de fiabilidad fue fundamental para el desarrollo de sistemas más complejos como los de multiprogramación y tiempo compartido, característicos de esta generación."
"¿Por qué es necesario el mecanismo de independencia de dispositivo de E/S en un sistema operativo moderno?",1,"[""Para permitir que los programadores creen sus propios manejadores de dispositivos"", ""Para que los programas no tengan que preocuparse por las características específicas de cada dispositivo físico""]",1,"Como se explica en la sección 1.3.2, la independencia de dispositivo de E/S permite que los programas se escriban para usar dispositivos lógicos de E/S creados por el sistema operativo, siendo este el que hace corresponder los dispositivos lógicos con los físicos. Esto significa que los programas no necesitan conocer las características específicas de cada dispositivo físico, ya que el acceso a los dispositivos lógicos siempre se hace de la misma manera (mismas operaciones, mismas abstracciones de datos, etc.). Esta abstracción simplifica enormemente la programación de aplicaciones en sistemas operativos modernos."
"En el contexto de la administración de memoria, ¿cuál es una de las responsabilidades fundamentales del sistema operativo?",1,"[""Optimizar el espacio utilizado por cada programa compilando su código de manera más eficiente"", ""Llevar un control de qué zonas de memoria se están usando y qué procesos las usan""]",1,"Como se indica en la sección 1.5.1, algunas de las actividades relacionadas con la administración de memoria de las que el sistema operativo es responsable incluyen llevar un control de qué zonas de memoria se están usando y qué procesos las usan, decidir qué procesos se cargarán en memoria cuando haya suficiente espacio disponible, y asignar y recuperar el espacio de memoria según se requiera. La optimización del código durante la compilación es responsabilidad del compilador, no del sistema operativo."
"¿Cuál es la principal diferencia entre la función del intérprete de mandatos (shell) y las llamadas al sistema en un sistema operativo moderno?",1,"[""El intérprete de mandatos define la perspectiva del sistema para los usuarios no programadores, mientras que las llamadas al sistema definen la interfaz para los programadores"", ""El intérprete de mandatos solo puede ejecutar comandos predefinidos, mientras que las llamadas al sistema permiten crear nuevas funcionalidades""]",0,"Como se explica en las secciones 1.5.3 y 1.5.4, mientras que las llamadas al sistema definen la interfaz con el programador, la perspectiva del sistema operativo que tienen la mayoría de los usuarios es la definida por los programas del sistema, especialmente el intérprete de mandatos u órdenes (shell). Por tanto, el diseño de una interfaz útil y amigable con el usuario no programador depende de los programas del sistema que acompañan al sistema operativo, y no es una función directa de este."
"¿Qué cambio fundamental en la interacción usuario-máquina se produjo entre la primera y la segunda generación de sistemas operativos?",1,"[""En la primera generación el programador interactuaba directamente con la máquina, mientras que en la segunda se perdió esta interactividad en favor de la eficiencia"", ""En la primera generación los ordenadores solo podían realizar una tarea a la vez, mientras que en la segunda apareció la multitarea""]",0,"Como se describe en las secciones 1.3.1 y 1.3.2, en la primera generación existía una interacción directa entre el programador y la máquina: cada programador reservaba la máquina a una hora determinada y la tenía por completo a su disposición. En la segunda generación, para evitar pérdidas de tiempo por la falta de experiencia de los programadores en la preparación de la máquina, se contrataron operadores profesionales, lo que hizo que los programadores perdieran la interacción directa con la máquina, interacción que no recuperarían hasta la siguiente generación con los sistemas de tiempo compartido."
"¿Qué diferencia fundamental existe entre la protección y la seguridad en un sistema operativo moderno?",1,"[""La protección se refiere a mecanismos internos que aíslan procesos entre sí, mientras que la seguridad abarca medidas contra amenazas externas"", ""La protección solo se aplica a los recursos hardware, mientras que la seguridad solo afecta a los recursos software""]",0,"Según la sección 1.5.2, la protección implica revisar la validez de los parámetros de las llamadas al sistema y asegurar que todo acceso a los recursos esté controlado, permitiendo que cada usuario controle el uso de su información. La seguridad, en cambio, se refiere a la protección del sistema respecto a personas ajenas, comenzando con las contraseñas para acceder a los recursos y extendiéndose a la protección contra intentos de acceso no permitidos desde conexiones remotas. Así, la protección se centra en mecanismos internos para aislar procesos y usuarios, mientras que la seguridad aborda amenazas externas."
"En el modelo cliente-servidor con micronúcleo, ¿por qué se prefiere que los servidores ejecuten mensajes especiales capturados por el micronúcleo en lugar de incluir los servidores en el núcleo?",1,"[""Para reducir el tamaño total del código del sistema operativo en memoria"", ""Para mantener las ventajas de seguridad y fiabilidad de ejecutar los servidores en modo usuario""]",1,"Como se explica en la sección 1.6.3, existen dos soluciones para que los servidores puedan realizar operaciones privilegiadas: incluirlos en el núcleo o usar mensajes especiales capturados por el micronúcleo. La segunda opción es preferible porque mantiene todas las ventajas de ejecutar los servidores en modo usuario, como el aislamiento de fallos (un fallo en un servidor no afecta al resto del sistema) y la seguridad (el micronúcleo verifica si el servidor tiene permiso para realizar la operación solicitada)."
"¿Qué ventaja ofrecen los sistemas operativos distribuidos sobre los sistemas operativos de red en términos de gestión de recursos?",1,"[""Los sistemas distribuidos ofrecen transparencia de localización, por lo que los usuarios no necesitan conocer dónde se encuentran físicamente los recursos"", ""Los sistemas distribuidos solo permiten la ejecución local de programas, lo que optimiza el uso de recursos""]",0,"Como se explica en la sección 1.4.3, en los sistemas operativos distribuidos el usuario no es consciente del lugar donde se ejecutan sus programas ni dónde se encuentran sus ficheros (transparencia de localización). Esto contrasta con los sistemas operativos de red (sección 1.4.2), donde los usuarios son conscientes de la existencia de varios ordenadores conectados mediante una red, y deben saber explícitamente en qué máquina se encuentran los recursos que desean utilizar."
"¿Qué problema fundamental de los primeros sistemas de procesamiento por lotes intentó resolver la introducción de las tarjetas de control?",1,"[""La necesidad de una forma estandarizada para que los usuarios especificaran qué operaciones deseaban realizar con sus trabajos"", ""La lentitud en la carga manual de programas mediante conmutadores en la consola""]",0,"Como se explica en la sección 1.3.2, durante la transición de la primera a la segunda generación, se desarrolló el sistema de procesamiento por lotes, que dio lugar a los primeros sistemas operativos rudimentarios como el monitor residente. Este sistema interpretaba las instrucciones de las tarjetas de control insertadas entre las tarjetas normales de datos, que indicaban el inicio y final de un trabajo, el tipo de trabajo a realizar (compilación, ejecución, etc.). Estas tarjetas proporcionaban una forma estandarizada para que los usuarios especificaran sus necesidades, similar a las órdenes que hoy se introducen por teclado en una consola."
"En el contexto de la estructura de los sistemas operativos, ¿qué ventaja principal ofrece el modelo cliente-servidor con micronúcleo para el desarrollo de sistemas distribuidos?",1,"[""Mayor eficiencia en la ejecución de código al minimizar las transiciones entre modo usuario y modo núcleo"", ""Un cliente se comunica con el servidor mediante mensajes independientemente de si están en la misma o en diferentes máquinas""]",1,"Como se indica en la sección 1.6.3, una ventaja del modelo cliente-servidor es su capacidad de adaptación a los sistemas distribuidos. Un cliente se comunica con el servidor por medio de mensajes, sin importar si ambos están en la misma o en diferentes máquinas. En lo que respecta al cliente, ocurre lo mismo en ambos casos: se envía una solicitud y se recibe una respuesta. Esta transparencia en la comunicación facilita enormemente el desarrollo de sistemas distribuidos, ya que los clientes no necesitan conocer la ubicación física de los servidores."
"¿Qué concepto fundamental de los sistemas operativos permite que múltiples programas compartan la CPU sin interferir entre sí?",1,"[""La combinación de modos de ejecución, protección de memoria e interrupciones periódicas"", ""La virtualización completa del hardware mediante hipervisores""]",0,"Como se explica en la sección 1.2, la protección del sistema operativo y la separación entre programas requiere tres mecanismos hardware básicos que deben funcionar conjuntamente: modos de ejecución del procesador (para distinguir código privilegiado de código de usuario), protección de la memoria (para evitar que un programa acceda a zonas de memoria de otros), e interrupciones periódicas (para que el sistema operativo pueda retomar el control periódicamente y reasignar la CPU). Esta combinación permite la multiprogramación y el tiempo compartido, donde múltiples programas pueden compartir la CPU sin interferir entre sí."
"¿Qué característica fundamental distingue a la quinta generación de sistemas operativos (1995-actualidad) de las generaciones anteriores?",1,"[""La capacidad de ejecutar múltiples programas simultáneamente mediante multiprogramación"", ""La adaptación a paradigmas de conexión, movilidad y computación en la nube""]",1,"Como se indica en la sección 1.3.5, lo que caracteriza a la quinta generación es la explosión del uso de Internet (y sus servicios como el cloud computing) y la proliferación de dispositivos móviles. Los sistemas operativos de esta generación han tenido que adaptarse a nuevos paradigmas de conexión, movilidad y computación en la nube, a diferencia de las generaciones anteriores que se centraban en mejoras de hardware, multiprogramación o interfaces gráficas."
"¿Qué componente fundamental del sistema operativo es responsable de controlar el acceso a los recursos definidos en un sistema de computación?",1,"[""El sistema de protección"", ""El planificador de CPU""]",0,"Como se describe en la sección 1.5.1, el sistema de protección es el componente responsable de controlar el acceso de los procesos (y, por ende, de los usuarios) a los recursos definidos en un sistema de computación: ficheros, impresoras, unidades de disco, etc. Este mecanismo debe ofrecer un medio para especificar los controles que se impondrán junto con la manera de ponerlos en práctica, asegurando que los recursos solo puedan ser usados por aquellos procesos que han recibido la correspondiente autorización."
"En el contexto de la evolución histórica de los sistemas operativos, ¿qué innovación de la segunda generación fue crucial para la posterior aparición de la multitarea?",1,"[""La introducción de los buffers y spoolers que permitían la superposición de E/S y cómputo"", ""El desarrollo de sistemas de procesamiento por lotes con tarjetas de control""]",0,"Como se explica en la sección 1.3.2 la introducción de buffers y spoolers en la segunda generación permitió la superposición de la E/S y el cómputo logrando que ambos funcionaran en paralelo. Con los spoolers incluso se consiguió la superposición de la E/S de unos programas con el cómputo de otros. El texto señala explícitamente que "es en la multiprogramación y en el tiempo compartido que aparecen en la siguiente generación donde esta técnica mostrará todo su potencial". Por tanto estos mecanismos sentaron las bases conceptuales para la posterior multitarea y multiprogramación."
"¿Cuál es la principal diferencia entre un programa del sistema y una llamada al sistema?",1,"[""Los programas del sistema son aplicaciones completas que se ejecutan en modo usuario, mientras que las llamadas al sistema son interfaces para acceder a servicios del núcleo"", ""Los programas del sistema solo pueden ser ejecutados por administradores, mientras que las llamadas al sistema están disponibles para cualquier usuario""]",0,"Como se explica en las secciones 1.5.3 y 1.5.4, las llamadas al sistema definen la interfaz entre el sistema operativo y un programa en ejecución, permitiendo el acceso a los servicios del núcleo. Son instrucciones en ensamblador que hacen que la ejecución pase de modo usuario a modo núcleo. En cambio, los programas del sistema son programas que acompañan al sistema operativo para ofrecer un entorno más cómodo para el desarrollo y ejecución de programas (editores, compiladores, herramientas de manipulación de ficheros, etc.). Desde el punto de vista del sistema operativo, no existe diferencia entre un programa del sistema y un programa de usuario; ambos son aplicaciones que se ejecutan en modo usuario y utilizan llamadas al sistema para acceder a servicios del núcleo."