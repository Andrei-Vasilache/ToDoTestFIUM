texto_pregunta,tema_id,opciones,indices_correctos,explicacion,dificultad
"En un sistema con paginación, si el bit de modificación de una página está activado, ¿qué implica esto cuando la página debe ser expulsada de memoria?",5,"[""La página debe ser escrita en disco antes de ser reemplazada"", ""La página puede ser descartada directamente sin escribirla en disco""]",0,"Cuando el bit de modificación (bit M) de una página está activado, indica que el contenido de esa página ha sido modificado mientras estaba en memoria. Por lo tanto, si se necesita expulsar esta página de memoria, su contenido actualizado debe escribirse en disco para no perder las modificaciones realizadas, como se explica en la sección 5.3.2 del texto sobre la estructura de una entrada en la tabla de páginas.",dificil
"En el algoritmo de reemplazo de páginas NRU (No Usada Recientemente), ¿qué clase de página se elige primero para ser reemplazada?",5,"[""Clase 0: R=0, M=0"", ""Clase 3: R=1, M=1""]",0,"Según el algoritmo NRU explicado en la sección 5.3.4, las páginas se dividen en cuatro categorías según los valores de los bits R (referencia) y M (modificación). El algoritmo elimina una página al azar de la primera clase no vacía de número más pequeño. La Clase 0 (R=0, M=0) representa las páginas que no han sido utilizadas recientemente ni modificadas, siendo las mejores candidatas para reemplazo.",dificil
"En un sistema con tablas de páginas multinivel, si una dirección virtual de 32 bits tiene un tamaño de página de 4KiB y se divide en PT1 y PT2 de 10 bits cada uno, ¿cuántos bytes de memoria principal representa cada entrada de la tabla de primer nivel?",5,"[""4MiB"", ""1MiB""]",0,"Como se explica en la sección 5.3.2 sobre tablas de páginas de varios niveles, cada una de las 1024 entradas de la tabla de páginas del nivel superior (10 bits de PT1) representa 4MiB del espacio de direcciones virtuales, ya que el tamaño total de este espacio es de 4GiB y la tabla de primer nivel divide dicho espacio en 1024 partes iguales.",dificil
"En la técnica de copia en escritura (COW) utilizada con fork(), ¿cuándo se crea realmente una copia de la página compartida?",5,"[""Cuando alguno de los procesos intenta escribir en ella"", ""Inmediatamente después de ejecutar la llamada fork()""]",0,"Como se explica en la sección 5.3.3 sobre el mapa de memoria de un proceso, en la técnica de copia en escritura (copy on write o COW), inicialmente todas las páginas de las regiones modificables se comparten con permiso de escritura desactivado. Solo cuando uno de los procesos intenta escribir en una de esas páginas se genera una excepción, y el sistema operativo crea una copia de la página en un nuevo marco para el proceso que intentó la escritura.",dificil
"En un sistema con paginación, ¿qué ocurre cuando se produce un fallo de TLB pero la página está en memoria?",5,"[""Se accede a la tabla de páginas en memoria para obtener el marco correspondiente y se actualiza el TLB"", ""Se genera un fallo de página que debe ser resuelto por el sistema operativo""]",0,"Según lo explicado en la sección 5.3.2 sobre el TLB, cuando se produce un fallo de TLB (la entrada buscada no está en el TLB), pero la página correspondiente sí está en memoria, la MMU hace una búsqueda normal en la tabla de páginas, obtiene la entrada correspondiente y la copia en el TLB, reemplazando alguna entrada existente. No se genera un fallo de página, que solo ocurriría si la página no estuviera en memoria.",dificil
"En un sistema de memoria con paginación, si una dirección virtual es 0x00403004 y el tamaño de página es 4KiB (4096 bytes), ¿cuál es el número de página?",5,"[""0x00403"", ""0x004""]",0,"Como se explica en la sección 5.3.2 sobre tablas de páginas de varios niveles, con un tamaño de página de 4KiB (4096 bytes), se necesitan 12 bits para el desplazamiento dentro de la página. Por lo tanto, los 20 bits más significativos de la dirección virtual 0x00403004 (es decir, 0x00403) forman el número de página.",dificil
"En un sistema con tablas de páginas invertidas, si varios procesos comparten una misma página, ¿cómo se refleja esto en la tabla de traducción?",5,"[""Existirán múltiples entradas en la tabla de traducción para el mismo marco, una por cada proceso que lo comparte"", ""Existe una única entrada en la tabla de traducción que contiene una lista de todos los procesos que comparten el marco""]",0,"Como se explica en la sección 5.3.2 sobre tablas de páginas invertidas, cuando los procesos comparten marcos (por ejemplo, cuando un proceso padre comparte con sus procesos hijos los marcos que contienen el código), para un mismo marco pueden existir dos o más entradas asociadas en la tabla de traducción, una por cada proceso y página virtual que lo utiliza.",dificil
"En un algoritmo de reemplazo de páginas LRU (Menos Recientemente Usada), ¿qué implementación hardware permite determinar qué página se usó hace más tiempo?",5,"[""Un contador que se incrementa automáticamente y se almacena en cada entrada de la tabla de páginas al acceder a una página"", ""Un bit de referencia que se activa cuando se accede a una página""]",0,"Como se describe en la sección 5.3.4 sobre el algoritmo LRU, una implementación hardware eficiente consiste en tener un contador especial C de 64 bits que se incrementa automáticamente tras cada referencia a memoria. Este valor se copia en la entrada correspondiente de la tabla de páginas (o del TLB) cada vez que se accede a una página. La página con el valor más bajo de contador será la que se usó hace más tiempo.",dificil
"En un sistema de paginación, la técnica de 'escritura anticipada' para páginas modificadas:",5,"[""Reduce el tiempo de resolución de fallos de página al evitar escrituras en disco durante la expulsión de páginas"", ""Aumenta el rendimiento al garantizar que todas las páginas modificadas se escriban inmediatamente en disco""]",0,"Como se explica en la sección 5.3.5 sobre políticas de lectura y escritura de páginas, la escritura anticipada utiliza un demonio de paginación que periódicamente escribe en disco las páginas modificadas. Esto reduce el tiempo de resolución de fallos de página, ya que cuando hay que expulsar una página modificada, ésta ya está actualizada en disco y no hay que esperar a escribirla.",dificil
"En un sistema con paginación, ¿qué ventaja principal ofrece el uso de páginas de gran tamaño?",5,"[""Tablas de páginas más pequeñas que ocupan menos memoria"", ""Menor fragmentación interna""]",0,"Como se explica en la sección 5.3.5 sobre tamaño de página, las páginas grandes producen tablas de páginas más pequeñas que ocupan menos memoria. Esto hace que el cambio de proceso sea más rápido si hay entradas de la tabla de páginas del nuevo proceso que deben cargarse, por ejemplo, en el TLB. Sin embargo, el inconveniente es que producen mayor fragmentación interna.",dificil
"En la segmentación paginada, ¿qué ocurre cuando se produce un fallo de TLB?",5,"[""Se accede a la tabla de segmentos para encontrar la tabla de páginas del segmento correspondiente, y luego se busca en esta tabla la entrada correspondiente a la página"", ""Se genera automáticamente una excepción que el sistema operativo debe manejar cargando el segmento completo desde disco""]",0,"Como se muestra en la figura 5.36 y se explica en la sección 5.5 sobre segmentación paginada, cuando se produce un fallo de TLB, el sistema debe acceder primero a la tabla de segmentos para encontrar la dirección de la tabla de páginas del segmento correspondiente. Luego, accede a esta tabla de páginas para obtener el marco asociado a la página y actualiza el TLB con esta información.",dificil
"En un sistema con memoria virtual, el bit 'presente/ausente' en una entrada de la tabla de páginas:",5,"[""Indica si la página está actualmente en memoria principal o no"", ""Indica si la página ha sido modificada desde que se cargó en memoria""]",0,"Como se explica en la sección 5.3.1 sobre funcionamiento de la paginación, el bit presente/ausente (también llamado bit de validez) en cada entrada de la tabla de páginas indica si la página está asociada a un marco en memoria principal (presente=1) o no está en memoria (ausente=0). Cuando se intenta acceder a una página con este bit en 0, se produce un fallo de página.",dificil
"En un sistema de paginación, ¿qué problema principal resuelven las tablas de páginas invertidas?",5,"[""El excesivo tamaño de las tablas de páginas convencionales en sistemas con espacios de direcciones virtuales muy grandes"", ""La fragmentación interna causada por el uso de páginas de tamaño fijo""]",0,"Como se explica en la sección 5.3.2 sobre tablas de páginas invertidas, éstas se utilizan para solucionar el problema del excesivo tamaño que tendrían las tablas de páginas convencionales en arquitecturas de 64 bits, donde la tabla de páginas de cada proceso podría ocupar 32 PiB de memoria con páginas de 4 KiB, lo que sería inviable.",dificil
"En el algoritmo de reemplazo de páginas 'del reloj', ¿cuál es la diferencia fundamental con el algoritmo de 'segunda oportunidad'?",5,"[""La implementación: el algoritmo del reloj utiliza una lista circular con un puntero en lugar de desplazar constantemente las páginas en una lista"", ""El criterio de selección: el algoritmo del reloj elige la página que lleva más tiempo sin ser referenciada, mientras que el de segunda oportunidad elige la más antigua""]",0,"Como se explica en la sección 5.3.4 sobre el algoritmo del reloj, éste difiere del algoritmo de segunda oportunidad solo en la implementación, no en su comportamiento. Mientras que la segunda oportunidad desplaza constantemente las páginas en una lista (lo que es ineficiente), el reloj mantiene las páginas en una lista circular con un puntero o 'manecilla' que avanza, evitando el desplazamiento continuo de páginas.",dificil
"En un sistema con paginación, ¿qué técnica permite reducir el número de referencias a memoria al traducir direcciones virtuales a físicas?",5,"[""El uso de un TLB (Translation Look-aside Buffer)"", ""El uso de tablas de páginas de varios niveles""]",0,"Como se explica en la sección 5.3.2 sobre TLB, este es un pequeño dispositivo hardware (una memoria asociativa dentro de la MMU) que contiene entradas de la tabla de páginas más utilizadas. Su objetivo es acelerar la traducción de direcciones virtuales a físicas sin tener que acceder a la tabla de páginas en memoria principal, reduciendo así el número de referencias a memoria durante la traducción.",dificil
"En un sistema con paginación, ¿qué ocurre cuando se produce hiperpaginación?",5,"[""El sistema pasa más tiempo resolviendo fallos de página que ejecutando instrucciones útiles"", ""La memoria principal se fragmenta excesivamente, requiriendo una compactación""]",0,"Como se explica en la sección 5.3.5 sobre hiperpaginación, ésta se produce cuando un proceso emplea más tiempo esperando a que se resuelvan sus fallos de página que ejecutando código. Esto ocurre típicamente cuando se necesitan muchos más marcos de los que se dispone, lo que causa un ciclo continuo de expulsión y carga de páginas.",dificil
"En la técnica de 'caché de páginas', implementada por el demonio de paginación, ¿qué ocurre con las páginas liberadas?",5,"[""El contenido de las páginas liberadas no se elimina inmediatamente de memoria, pudiendo ser recuperado si se necesita pronto"", ""Las páginas liberadas se escriben inmediatamente en disco y sus marcos se marcan como disponibles""]",0,"Como se explica en la sección 5.3.5 sobre políticas de lectura y escritura, en la técnica de caché de páginas, el contenido de las páginas liberadas no tiene por qué eliminarse de memoria principal. Solo cuando el marco que ocupa una de estas páginas se necesite, su contenido se podrá descartar. De esta manera, si una página liberada se necesita poco después, su contenido podría encontrarse todavía en memoria.",dificil
"En un sistema con paginación, ¿qué problema principal produce el uso de tablas de páginas de un solo nivel en arquitecturas de 64 bits?",5,"[""El tamaño excesivo de las tablas de páginas, que ocuparían más memoria de la disponible físicamente"", ""La fragmentación externa causada por la necesidad de mantener las tablas de páginas en memoria contigua""]",0,"Como se menciona en la sección 5.3.2 sobre tablas de páginas de varios niveles, en procesadores con arquitecturas de 64 bits, las tablas de páginas de un solo nivel serían enormes. Por ejemplo, con direcciones de 64 bits y páginas de 4 KiB, cada tabla de páginas tendría 2^52 entradas, ocupando 32 PiB de memoria con entradas de 8 bytes, lo que es totalmente inviable.",dificil
"En un sistema con paginación, ¿qué ventaja principal ofrece la política de reemplazo de páginas global frente a la local?",5,"[""Permite una asignación dinámica y más eficiente del número de marcos entre los diferentes procesos"", ""Garantiza que un proceso nunca experimentará hiperpaginación, ya que siempre tendrá un número fijo de marcos""]",0,"Como se explica en la sección 5.3.5 sobre políticas de reemplazo y asignación, el reemplazo global permite una asignación dinámica de marcos entre procesos, ya que la página a reemplazar se elige entre todos los marcos disponibles en la memoria principal. Esto hace que cambie el número de marcos asignados a cada proceso según sus necesidades, logrando una asignación más eficiente.",dificil
"En segmentación paginada, ¿cómo se organiza la memoria virtual de un proceso?",5,"[""Los segmentos de tamaño variable se dividen en páginas de tamaño fijo"", ""Las páginas de tamaño fijo se agrupan en segmentos de tamaño variable""]",0,"Como se explica en la sección 5.5 sobre segmentación paginada, en esta técnica se paginan los segmentos, es decir, cada segmento (que puede tener un tamaño variable según su propósito) se divide en un número determinado de páginas de tamaño fijo. Esto elimina la fragmentación externa que sufría la segmentación pura, aunque mantiene cierta fragmentación interna.",dificil
"En un sistema con tablas de páginas invertidas, ¿cuál es el factor principal que determina el tamaño mínimo de la tabla de traducción?",5,"[""El número de marcos de página en la memoria física"", ""El número de procesos activos en el sistema""]",0,"Como se explica en la sección 5.3.2 sobre tablas de páginas invertidas, existe una tabla de traducción con una entrada por cada marco de página de la memoria física, por lo que su tamaño depende únicamente de la cantidad de memoria física disponible, no del tamaño del espacio de direcciones virtuales. El número de marcos en memoria principal nos da el número mínimo de entradas en la tabla de traducción.",dificil
"En la política de 'prepaginación' o 'paginación anticipada', ¿qué estrategia se sigue cuando ocurre un fallo de página?",5,"[""Se leen la página que provocó el fallo y varias páginas contiguas en el espacio de direcciones virtuales"", ""Se leen solo aquellas páginas que el sistema predice que serán necesarias basándose en el historial de accesos""]",0,"Como se explica en la sección 5.3.5 sobre políticas de lectura y escritura de páginas, en la prepaginación o paginación anticipada, cuando ocurre un fallo de página, el sistema lee no solo la página que provocó el fallo, sino también varias páginas adicionales, generalmente las que se encuentran a continuación en el espacio de direcciones virtuales, anticipándose a posibles accesos futuros.",dificil
"En la traducción de direcciones virtuales a físicas en un sistema con paginación, si el tamaño de página es potencia de 2, ¿qué ventaja principal ofrece esto?",5,"[""Permite realizar la traducción mediante selección de bits en lugar de operaciones aritméticas, lo que es mucho más rápido"", ""Garantiza que todas las páginas pueden alinearse perfectamente en la memoria física sin fragmentación""]",0,"Como se explica en la sección 5.3.1 sobre funcionamiento de la paginación, cuando el tamaño de página es potencia de 2, la traducción de direcciones virtuales a físicas se puede realizar mediante simple selección de bits, evitando costosas operaciones aritméticas como divisiones. Esto hace que el proceso de traducción sea mucho más rápido, lo cual es crucial dado que toda referencia a memoria requiere una traducción.",dificil
"En un sistema con paginación, ¿qué técnica permite que varios procesos compartan eficientemente el mismo código?",5,"[""Mapear las mismas páginas físicas que contienen el código en los espacios de direcciones virtuales de todos los procesos involucrados"", ""Crear copias independientes del código para cada proceso y sincronizarlas periódicamente""]",0,"Como se explica en la sección 5.3.3 sobre el mapa de memoria de un proceso, la paginación permite compartir eficientemente código entre procesos mapeando las mismas páginas físicas (marcos) que contienen el código en los espacios de direcciones virtuales de todos los procesos que lo comparten. Esto es posible porque las páginas de código son de solo lectura, por lo que no hay problemas de coherencia.",dificil
"En un sistema con paginación, cuando se ejecuta 'fork()', ¿qué técnica permite crear eficientemente un proceso hijo con el mismo espacio de direcciones que el padre?",5,"[""La técnica de copia en escritura (COW), que permite compartir páginas entre padre e hijo hasta que uno intente modificarlas"", ""La creación inmediata de copias de todas las páginas del padre para el hijo, garantizando total independencia""]",0,"Como se explica en la sección 5.3.3 sobre el mapa de memoria de un proceso, cuando se ejecuta fork(), se utiliza la técnica de copia en escritura (COW). Inicialmente, el hijo comparte todas las páginas con el padre (incluso las modificables), pero se desactiva el permiso de escritura. Solo cuando uno de los procesos intenta escribir en una página compartida, se crea una copia para ese proceso, lo que hace muy eficiente la creación de procesos.",dificil
"En un sistema con tablas de páginas de dos niveles, ¿qué ocurre si una entrada de la tabla de primer nivel indica que no existe la tabla de segundo nivel correspondiente?",5,"[""Se produce un fallo de página, ya que no existe ninguna asociación entre las páginas virtuales de ese bloque y marcos de memoria física"", ""Se crea automáticamente una nueva tabla de segundo nivel y se actualiza la entrada de la tabla de primer nivel para referenciarla""]",1,"Aunque no se menciona explícitamente en el texto, cuando una entrada de la tabla de primer nivel indica que no existe la tabla de segundo nivel correspondiente (porque el bit presente/ausente está en 0 o porque el puntero es nulo), se produce un fallo de página. Esto ocurre porque no existe ninguna asociación entre las páginas virtuales de ese bloque de direcciones y marcos de memoria física, y el sistema operativo debe determinar cómo manejar este acceso a memoria.",dificil
"En un sistema con paginación, ¿qué ocurre cuando un proceso intenta escribir en una página que tiene desactivado el permiso de escritura?",5,"[""El hardware genera automáticamente una nueva página con contenido idéntico pero con permisos de escritura"", ""Se genera una excepción que el sistema operativo debe manejar, posiblemente terminando el proceso o implementando COW si corresponde""]",1,"Como se explica en la sección 5.3.3 sobre el mapa de memoria de un proceso, cuando un proceso intenta escribir en una página que tiene desactivado el permiso de escritura, se genera una excepción (violación de acceso) que debe ser manejada por el sistema operativo. Dependiendo del contexto, el SO puede terminar el proceso por acceso ilegal o, si la página está compartida mediante COW, crear una copia privada para el proceso.",dificil
"En un sistema con memoria virtual, ¿cuál es la principal desventaja de utilizar un tamaño de página muy grande?",5,"[""Reduce el número de entradas en la tabla de páginas, lo que disminuye la flexibilidad del sistema"", ""Aumenta la fragmentación interna, desperdiciando memoria si los procesos no utilizan completamente las páginas""]",1,"Como se explica en la sección 5.3.5 sobre tamaño de página, una de las principales desventajas de utilizar páginas grandes es que producen una mayor fragmentación interna. Esto ocurre porque si un proceso no utiliza completamente una página, el espacio restante se desperdicia, y este problema es proporcionalmente mayor cuanto más grande es la página.",dificil
"En el algoritmo de reemplazo de páginas LRU (Menos Recientemente Usada), ¿cuál es su principal desventaja en implementaciones reales?",5,"[""Es óptimo en teoría pero impredecible en la práctica porque no puede anticipar referencias futuras"", ""Requiere hardware especial o un alto costo computacional para determinar exactamente qué página se usó hace más tiempo""]",1,"Como se explica en la sección 5.3.4 sobre el algoritmo LRU, su principal inconveniente es cómo implementarlo de forma eficiente. Las implementaciones exactas de LRU requieren hardware especial (como contadores o matrices) que no siempre está disponible, y las implementaciones en software pueden tener un alto costo computacional o ser aproximaciones imperfectas (como el algoritmo de maduración).",dificil
"En un sistema con tablas de páginas invertidas, ¿qué estructura adicional es necesaria para hacer eficiente la traducción de direcciones virtuales a físicas?",5,"[""Un registro que apunta a la tabla de páginas invertida del proceso actual"", ""Una tabla de dispersión y un TLB para evitar tener que buscar en toda la tabla en cada traducción""]",1,"Como se explica en la sección 5.3.2 sobre tablas de páginas invertidas, para hacer eficiente la traducción, se utiliza una tabla de dispersión que, dados el identificador del proceso y el número de página virtual, proporciona una entrada aproximada en la tabla de traducción. Además, se utiliza un TLB para almacenar las traducciones recientes y evitar acceder a la tabla en memoria.",dificil
"En un sistema con paginación, ¿en qué caso la 'caché de páginas' puede mejorar significativamente el rendimiento?",5,"[""Cuando hay muy pocos fallos de página y la mayoría de accesos son satisfechos por el TLB"", ""Cuando un proceso accede repetidamente a páginas que fueron recientemente liberadas pero aún están físicamente en memoria""]",1,"Como se explica en la sección 5.3.5 sobre políticas de lectura y escritura, en la técnica de caché de páginas, el contenido de las páginas liberadas no se elimina inmediatamente de memoria. Si una página liberada se necesita poco después, su contenido podría encontrarse todavía en memoria y recuperarse rápidamente sin necesidad de leerla de disco, mejorando significativamente el rendimiento en patrones de acceso que vuelven a usar páginas recientemente liberadas.",dificil
"En un sistema con segmentación paginada, ¿qué ventaja principal ofrece frente a la segmentación pura?",5,"[""Elimina la necesidad de tener tablas de segmentos, simplificando la gestión de memoria"", ""Elimina la fragmentación externa mientras mantiene las ventajas conceptuales de la segmentación""]",1,"Como se explica en la sección 5.5 sobre segmentación paginada, esta técnica paginando los segmentos hace que desaparezca la fragmentación externa (que era un problema importante en la segmentación pura), aunque mantiene cierta fragmentación interna. Además, mantiene las ventajas conceptuales de la segmentación, como la separación lógica de diferentes tipos de datos y código.",dificil
"En la política de asignación de huecos 'Mejor en ajustarse' para particiones variables, ¿cuál es su principal desventaja?",5,"[""Es más lenta que otras políticas porque debe examinar todos los huecos disponibles"", ""Tiende a producir huecos demasiado pequeños que no se pueden utilizar, desperdiciando memoria""]",1,"Como se explica en la sección 5.2.2 sobre multiprogramación con particiones variables, la política 'Mejor en ajustarse' presenta dos problemas. Por un lado, es lenta, pues tiene que buscar en todos los huecos. Por otro lado, y más importante, suele desperdiciar más memoria que otras políticas, ya que tiende a producir huecos demasiado pequeños que no se pueden utilizar para nuevas asignaciones.",dificil
"En un sistema con paginación, si se produce una excepción durante la ejecución de una instrucción que accede a múltiples páginas, ¿qué debe ocurrir cuando se resuelve la excepción?",5,"[""La instrucción continúa desde el punto exacto donde se produjo la excepción"", ""La instrucción debe reiniciarse desde el principio""]",1,"Como se explica en la sección 5.3.1 sobre funcionamiento de la paginación, cuando se produce un fallo de página, el sistema operativo debe resolver el fallo y luego reiniciar la instrucción que lo produjo. Esto es necesario porque la instrucción podría acceder a múltiples páginas, y si se continúa desde el punto de la excepción, se podría perder parte de la ejecución normal de la instrucción.",dificil
"En la combinación de políticas de reemplazo y asignación de páginas, ¿qué combinación no es posible implementar?",5,"[""Reemplazo local con asignación dinámica"", ""Reemplazo global con asignación fija""]",1,"Como se muestra en la tabla 5.1 de la sección 5.3.5 sobre políticas de reemplazo y asignación, la combinación de reemplazo global con asignación fija no es posible. Esto es lógico ya que el reemplazo global implica que la página a reemplazar se elige entre todos los marcos disponibles en memoria, lo que inevitablemente cambia el número de marcos asignados a cada proceso, lo cual es incompatible con la asignación fija.",dificil
"En un sistema con tablas de páginas multinivel, ¿cuál es la ventaja principal de no tener todas las tablas de páginas en memoria al mismo tiempo?",5,"[""Facilita la sincronización entre CPUs en sistemas multiprocesador"", ""Reduce significativamente la cantidad de memoria principal necesaria para las tablas de páginas""]",1,"Como se explica en la sección 5.3.2 sobre tablas de páginas de varios niveles, el secreto de este método consiste en no tener al mismo tiempo todas las tablas en la memoria; las que no son necesarias, no se tienen. Esto reduce significativamente la cantidad de memoria principal necesaria para las tablas de páginas, especialmente en sistemas con espacios de direcciones virtuales muy grandes donde la mayoría del espacio no se utiliza.",dificil
"En un sistema con paginación, el 'demonio de paginación' es un hilo del núcleo que:",5,"[""Resuelve los fallos de página cargando las páginas necesarias desde disco"", ""Periódicamente escribe páginas modificadas a disco y puede liberar marcos para anticiparse a futuros fallos de página""]",1,"Como se explica en la sección 5.3.5 sobre políticas de lectura y escritura, el demonio de paginación es un hilo del núcleo que periódicamente se despierta y escribe en disco las páginas modificadas. Además, puede liberar páginas eliminándolas de las tablas de páginas para tener un conjunto de marcos libres disponibles para futuros fallos de página, implementando lo que se conoce como caché de páginas.",dificil
"En un sistema con particiones variables, ¿cuál es la política de asignación de huecos que suele dar mejor resultado respecto al aprovechamiento de la memoria?",5,"[""Primero en ajustarse"", ""Peor en ajustarse""]",1,"Como se explica en la sección 5.2.2 sobre multiprogramación con particiones variables, la política 'Peor en ajustarse' toma siempre el hueco libre más grande. Su objetivo es que el nuevo hueco obtenido sea suficientemente grande para ser útil. Aunque es lenta, funciona bastante bien respecto al aprovechamiento de la memoria, mejor que otras políticas como 'Mejor en ajustarse' que tiende a crear huecos demasiado pequeños.",dificil