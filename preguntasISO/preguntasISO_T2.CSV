texto_pregunta,tema_id,opciones,indices_correctos,explicacion,dificultad
"La función fork() en Unix crea una copia del proceso padre donde el hijo comparte todos los segmentos con su padre.",2,"[""Verdadero"",""Falso""]",1,"Según el apartado 2.3.1, cuando se ejecuta fork(), se asigna memoria para los segmentos de datos y pila del hijo, copiando los del padre. Solo el segmento de código es compartido por razones de seguridad al ser de solo lectura.",dificil
"En el modelo de procesos de Unix, cuando un proceso realiza una llamada al sistema, se considera que:",2,"[""Se produce un cambio de proceso."",""Se mantiene en el mismo proceso pero cambia de modo usuario a modo núcleo.""]",1,"Según el apartado 2.3.2, en Unix cuando un proceso realiza una llamada al sistema, se considera que ese mismo proceso pasa de modo usuario a modo núcleo y ejecuta el código del sistema operativo.",dificil
"En la implementación de hilos en modo núcleo, si un hilo se bloquea por una llamada al sistema:",2,"[""Todos los hilos del mismo proceso también se bloquean."",""Otros hilos del mismo proceso pueden continuar ejecutándose.""]",1,"Según el apartado 2.4.3, una de las ventajas de implementar hilos en modo núcleo es que las llamadas al sistema bloqueantes no suponen un problema. Si un hilo se bloquea, el núcleo puede dar la CPU a otro hilo del mismo proceso o de otro proceso.",dificil
"Un cambio de contexto siempre implica un cambio de proceso, pero no al revés.",2,"[""Verdadero"",""Falso""]",1,"Según el apartado 2.1.2, un cambio de proceso siempre conlleva uno o más cambios de contexto, pero no al contrario. Por ejemplo, cuando un proceso realiza una llamada al sistema, se cambia de contexto sin cambiar de proceso.",dificil
"La planificación SJF (Shortest Job First) es apropiativa.",2,"[""Verdadero"",""Falso""]",1,"Según el apartado 2.5.4, el algoritmo SJF es no apropiativo. La versión apropiativa se denomina SRTF (Shortest-Remaining-Time First).",dificil
"En la planificación de múltiples colas con realimentación, los procesos:",2,"[""Solo pueden estar en una cola específica durante toda su ejecución."",""Pueden moverse entre diferentes colas según ciertos criterios.""]",1,"Según el apartado 2.5.4, en la planificación de múltiples colas con realimentación los procesos pueden cambiar de una cola a otra según criterios establecidos como tipo de proceso, consumo de CPU, etc.",dificil
"En la llamada al sistema execve() de Unix:",2,"[""Se crea un nuevo proceso independiente del que realiza la llamada."",""El proceso que realiza la llamada sufre una mutación completa sin crear un nuevo proceso.""]",1,"Según el apartado 2.1.3, execve() no crea un nuevo proceso, sino que simplemente cambia el código y los datos por otros dentro del mismo proceso. El proceso sufre una mutación completa pero sigue siendo el mismo proceso.",dificil
"Un proceso en estado 'bloqueado suspendido' puede pasar directamente al estado:",2,"[""En ejecución"",""Listo suspendido""]",1,"Según la figura 2.5 del apartado 2.2, un proceso en estado 'bloqueado suspendido' puede pasar al estado 'listo suspendido' cuando el evento por el que se bloqueó se produce mientras está suspendido.",dificil
"La eficiencia en la planificación de procesos se define como:",2,"[""El porcentaje de procesos que terminan su ejecución correctamente."",""El porcentaje de tiempo que la CPU está realizando trabajo útil respecto al tiempo total.""]",1,"Según el apartado 2.5.1, la eficiencia se define como (Tiempo_útil/Tiempo_total)×100, donde el tiempo total incluye tiempo útil, tiempo de gestión y tiempo ocioso.",dificil
"En la creación de un proceso mediante fork() en Unix, el segmento de código:",2,"[""Se copia del padre al hijo."",""Es compartido entre padre e hijo.""]",1,"Según el apartado 2.3.1, como el segmento de código es de solo lectura (por razones de seguridad), este segmento es compartido por padre e hijo al ejecutar fork().",dificil
"El BCP (Bloque de Control de Proceso) contiene:",2,"[""Solo la información necesaria para que el proceso continúe su ejecución tras perder la CPU."",""Además de la información para continuar la ejecución, también contiene datos estadísticos y de otro tipo.""]",1,"Según el apartado 2.3, en el PCB (o BCP en español) se guarda, al menos, todo aquello necesario para que el proceso continúe su ejecución tras perder la CPU, pero también se suelen guardar datos estadísticos y de otro tipo.",dificil
"Cuando un proceso padre en Unix realiza un fork() y luego el proceso hijo ejecuta execve():",2,"[""El hijo mantiene los mismos ficheros abiertos que tenía el padre."",""El hijo cierra todos los ficheros que tenía abiertos el padre.""]",0,"Según el apartado 2.1.3, cuando se ejecuta execve(), se conservan los ficheros abiertos, aunque hay una forma de especificar el cierre de ciertos descriptores de ficheros al emitir la llamada.",dificil
"En la planificación round robin con un quantum grande:",2,"[""Mejora el tiempo de respuesta para procesos interactivos."",""Disminuye el número de cambios de proceso pero empeora el tiempo de respuesta.""]",1,"Según el apartado 2.5.4, si el quantum es grande, la CPU se desperdicia poco al reducirse el número de cambios de proceso, pero los últimos procesos de la lista tardan mucho en ser atendidos, lo que puede suponer tiempos de respuesta muy pobres para procesos interactivos.",dificil
"Un proceso limitado por E/S típicamente:",2,"[""Tiene pocas ráfagas de CPU de larga duración."",""Tiene muchas ráfagas de CPU aunque breves.""]",1,"Según el apartado 2.5.3, un proceso limitado por E/S pasa la mayor parte de su tiempo en espera de operaciones de E/S y normalmente tendrá muchas ráfagas de CPU aunque breves.",dificil
"La ventaja principal de los hilos implementados en modo usuario respecto a los implementados en modo núcleo es:",2,"[""Mejor solapamiento de E/S con cómputo."",""Los cambios de contexto entre hilos son mucho más rápidos.""]",1,"Según el apartado 2.4.3, una de las ventajas de los hilos en modo usuario es que los cambios de contexto entre hilos son mucho más rápidos, ya que no es necesario pasar al núcleo del sistema operativo para realizarlos.",dificil
"En un sistema operativo con hilos implementados en modo usuario, si un hilo realiza una operación de E/S bloqueante:",2,"[""Solo ese hilo se bloquea, permitiendo que otros hilos del mismo proceso se ejecuten."",""Todo el proceso se bloquea, impidiendo que cualquier otro hilo del mismo proceso se ejecute.""]",1,"Según el apartado 2.4.3, uno de los inconvenientes de los hilos en modo usuario es que cualquier llamada al sistema bloqueante realizada por uno de los hilos bloqueará a todo el proceso y sus hilos.",dificil
"El algoritmo de planificación SJF (Shortest Job First) es óptimo para minimizar:",2,"[""El tiempo de respuesta."",""El tiempo promedio de regreso o retorno.""]",1,"Según el apartado 2.5.4, el algoritmo SJF es óptimo para los tiempos de regreso de los procesos, ya que proporciona el tiempo promedio de regreso mínimo.",dificil
"En la planificación por prioridad, el problema de inanición puede solucionarse:",2,"[""Aumentando periódicamente la prioridad de los procesos de baja prioridad que llevan tiempo esperando."",""Usando exclusivamente prioridades estáticas asignadas en la creación del proceso.""]",0,"Según el apartado 2.5.4, una solución al problema de inanición es aumentar periódicamente la prioridad de los procesos listos de baja prioridad, de modo que tarde o temprano serán los de mayor prioridad y usarán la CPU.",dificil
"Cuando se produce un fallo de página en un sistema con hilos implementados en modo núcleo:",2,"[""Todo el proceso se bloquea incluyendo todos sus hilos."",""Solo se bloquea el hilo que produjo el fallo, permitiendo que otros hilos del mismo proceso continúen ejecutándose.""]",1,"Según el apartado 2.4.3, con la implementación de hilos en modo núcleo, los fallos de página no representan un problema, pues se puede pasar a otro hilo del mismo proceso o de otro proceso.",dificil
"En la función fork() de Unix, la manera en que el proceso padre y el hijo pueden distinguirse es:",2,"[""Por una variable global que indica qué proceso es el padre y cuál es el hijo."",""Por el valor de retorno de la llamada fork(), que es diferente para padre e hijo.""]",1,"Según el apartado 2.1.3, tras la llamada al sistema fork(), la única diferencia entre padre e hijo es el valor devuelto por la función, que en el hijo es 0 y en el padre es un número que identifica al nuevo proceso (PID).",dificil
"La planificación 'primero el que tenga el menor tiempo restante' (SRTF) es:",2,"[""Una variante apropiativa del algoritmo FCFS."",""Una variante apropiativa del algoritmo SJF.""]",1,"Según el apartado 2.5.4, la planificación SJF puede hacerse apropiativa cuando se quita la CPU a un proceso para dársela a otro con tiempo restante menor, y a esta variante se le llama SRTF.",dificil
"En Unix, cuando un proceso realiza una llamada al sistema y luego se bloquea dentro del núcleo:",2,"[""El proceso permanece bloqueado en su parte del núcleo hasta que se desbloquee."",""El proceso continúa en estado bloqueado dentro del espacio de usuario.""]",0,"Según el apartado 2.3.2, es posible que una llamada al sistema haga que un proceso se bloquee dentro del núcleo, lo que provocará que ceda la CPU a otro proceso. Cuando se desbloquee, continuará su ejecución dentro del núcleo.",dificil
"El planificador a medio plazo (PMP) es responsable de:",2,"[""Gestionar el intercambio de procesos entre memoria principal y disco."",""Decidir qué proceso listo en memoria obtiene la CPU.""]",0,"Según el apartado 2.5.5, el planificador a medio plazo (PMP) es el que planifica el intercambio de procesos entre la memoria principal y el disco.",dificil
"En la estimación de tiempos de ejecución para el algoritmo SJF, si el coeficiente de credibilidad 'a' es cercano a 1:",2,"[""Se da mayor peso a las estimaciones anteriores, recordando los tiempos antiguos durante más tiempo."",""Se da mayor peso a los tiempos de ejecución más recientes.""]",0,"Según el apartado 2.5.4, un valor de 'a' grande hace que se recuerden durante largo tiempo los tiempos de las ejecuciones anteriores, dando más peso a las estimaciones previas que al último tiempo de ejecución real.",dificil
"En el mecanismo de cambio de proceso durante una llamada al sistema, la parte del sistema operativo que entrega el control de la CPU al proceso seleccionado se denomina:",2,"[""Despachador."",""Planificador.""]",0,"Según el apartado 2.3.3, a la parte del sistema operativo que entrega el control de la CPU al proceso seleccionado por el planificador se le denomina despachador.",dificil
"Cuando un proceso termina su ejecución en Unix y debe esperar a que su proceso padre recoja su estado de salida, se encuentra en el estado:",2,"[""Saliente."",""Bloqueado.""]",0,"Según el apartado 2.2, cuando un proceso termina su ejecución y debe esperar a que su proceso padre recoja su estado de salida mediante la llamada al sistema wait(), se encuentra en el estado 'Saliente'.",dificil
"El pseudoparalelismo se produce cuando:",2,"[""Una única CPU se pasa rápidamente de un proceso a otro dando la sensación de ejecución simultánea."",""Varios procesos se ejecutan simultáneamente en diferentes CPU o núcleos.""]",0,"Según el apartado 2.1.1, el pseudoparalelismo se da cuando una CPU se pasa rápidamente de un proceso a otro, dando la sensación de que se ejecutan al mismo tiempo sin ser así realmente.",dificil
"El mecanismo de suspensión de procesos es útil cuando:",2,"[""El sistema está muy cargado y se necesita reducir la carga para servir a procesos de mayor prioridad."",""El sistema está funcionando bien y hay suficiente memoria principal.""]",0,"Según el apartado 2.2, la suspensión de procesos es útil cuando el sistema está muy cargado y se necesita reducir la carga suspendiendo procesos para dar servicio a los de mayor prioridad.",dificil
"En la transición de estados de un proceso, un proceso en estado 'bloqueado' pasa directamente a estado 'en ejecución' cuando:",2,"[""Nunca puede pasar directamente, siempre debe pasar primero por el estado 'listo'."",""Ocurre el evento que esperaba y la CPU está libre.""]",0,"Según la figura 2.3 del apartado 2.2, cuando ocurre el evento que espera un proceso bloqueado, este pasa al estado 'listo'. Solo desde ahí puede pasar a 'en ejecución' cuando el planificador le asigne la CPU.",dificil
"La principal diferencia entre la llamada al sistema fork() en Unix y CreateProcess() en Windows es:",2,"[""fork() crea un proceso hijo idéntico al padre, mientras CreateProcess() directamente ejecuta un nuevo programa."",""fork() crea un proceso totalmente independiente, mientras CreateProcess() crea un proceso hijo que depende del padre.""]",0,"Según el apartado 2.1.3, CreateProcess() en Windows equivale a ejecutar fork() y execve() a la vez, creando un nuevo proceso para ejecutar un nuevo programa directamente, mientras que fork() solo crea un clon del proceso padre.",dificil
"El efecto convoy en la planificación FCFS se produce cuando:",2,"[""Procesos pequeños esperan detrás de un proceso que consume mucha CPU."",""Procesos grandes esperan detrás de muchos procesos pequeños.""]",0,"Según el apartado 2.5.4, el efecto convoy surge cuando un proceso limitado por CPU ocupa la CPU durante un largo período, mientras los procesos limitados por E/S esperan, provocando un uso ineficiente de los recursos.",dificil
"En la implementación de hilos, los elementos que se comparten entre todos los hilos de un mismo proceso incluyen:",2,"[""Las variables globales y los ficheros abiertos."",""La pila de ejecución y el contador de programa.""]",0,"Según el apartado 2.4.1, entre los elementos que se comparten entre todos los hilos de un proceso están las variables globales, los ficheros abiertos, el espacio de direcciones, etc.",dificil
"Si una aplicación necesita realizar cálculos intensivos en CPU y a la vez mantener una interfaz de usuario responsiva, la mejor estrategia sería:",2,"[""Crear un único proceso con múltiples hilos."",""Crear múltiples procesos independientes.""]",0,"Según el apartado 2.4.2, los hilos son adecuados cuando un programa realiza varias funciones diferentes, como en un programa gráfico donde un hilo puede atender la interfaz de usuario mientras otro realiza los cálculos, mejorando la experiencia del usuario.",dificil
"En los sistemas operativos modernos, el paralelismo real se consigue cuando:",2,"[""Varios procesos o hilos se ejecutan simultáneamente en diferentes CPU o núcleos."",""La CPU cambia rápidamente entre procesos dando la sensación de ejecución simultánea.""]",0,"Según el apartado 2.1.1, el paralelismo real se da cuando hay varias CPU o cuando una CPU dispone de varios núcleos, ya que en un mismo instante cada CPU o núcleo puede ejecutar un proceso distinto.",dificil
"La jerarquía de procesos en Windows, comparada con Unix, se caracteriza por:",2,"[""Ser más flexible, permitiendo que un proceso hijo pase a ser hijo de otro proceso que no sea su padre original."",""Ser más rígida, con relaciones padre-hijo estrictamente mantenidas.""]",0,"Según el apartado 2.1.3, en Windows un proceso hijo puede pasar a ser hijo de otro proceso que no sea su padre original, pudiendo transferir la 'propiedad' de un hijo a otro proceso, lo que hace que desaparezca el concepto de jerarquía estricta como en Unix.",dificil
"En la relación entre cambios de modo, contexto y proceso:",2,"[""Un cambio de modo siempre implica un cambio de contexto, pero no necesariamente un cambio de proceso."",""Un cambio de modo siempre implica un cambio de proceso.""]",0,"Según el apartado 2.1.2, un cambio de modo supone siempre un cambio de contexto, pero no un cambio de proceso, como ocurre en las llamadas al sistema donde se mantiene en el mismo proceso.",dificil
"Para favorecer a los procesos limitados por E/S en una planificación por prioridad dinámica, una estrategia eficaz es:",2,"[""Asignar mayor prioridad a los procesos que consumen menos de su quantum."",""Asignar menor prioridad a los procesos que consumen menos de su quantum.""]",0,"Según el apartado 2.5.4, para favorecer a los procesos limitados por E/S, la prioridad dinámica puede ser 1/F, donde F es la fracción del último quantum utilizada. Así, a menor uso del quantum (típico de procesos limitados por E/S), mayor prioridad.",dificil
"En el planificador a corto plazo (PCP), el criterio principal para seleccionar el siguiente proceso a ejecutar es:",2,"[""El estado del proceso (si está listo) y su prioridad según el algoritmo de planificación."",""La cantidad de memoria que consume el proceso.""]",0,"Según el apartado 2.5.5, el planificador a corto plazo es el que planifica los procesos que se encuentran en memoria, seleccionando entre los procesos listos según el algoritmo de planificación implementado (FCFS, SJF, prioridad, etc.).",dificil
"En la planificación round robin, si el quantum es extremadamente pequeño:",2,"[""La CPU puede pasar más tiempo haciendo cambios de proceso que ejecutando procesos útiles."",""El tiempo de respuesta mejora significativamente para todos los procesos.""]",0,"Según el apartado 2.5.4, si el quantum es excesivamente pequeño, la CPU puede pasar más tiempo realizando cambios de proceso que ejecutando procesos útiles, lo que disminuye la eficiencia.",dificil
"La ejecución concurrente de procesos en un sistema operativo es deseable porque:",2,"[""Permite que cada proceso tenga acceso exclusivo a todos los recursos del sistema."",""Facilita compartir recursos físicos y lógicos, y en ciertos casos acelera los cálculos.""]",1,"Según el apartado 2.1.1, la ejecución concurrente es deseable por razones como compartir recursos físicos y lógicos, acelerar cálculos, modularidad, y comodidad para los usuarios.",dificil
"En la técnica de maduración para estimar tiempos de ejecución en SJF, un valor de coeficiente de credibilidad 'a' pequeño significa que:",2,"[""Las estimaciones consideran principalmente los tiempos de ejecución más antiguos."",""Se olvidan rápidamente los tiempos antiguos, dando más peso al último tiempo de ejecución.""]",1,"Según el apartado 2.5.4, un valor de 'a' pequeño hace que se olviden con rapidez los tiempos de las ejecuciones anteriores, dando más peso al último tiempo de ejecución real.",dificil
"En el paralelismo pseudoparalelo, si comparamos el tiempo de ejecución total con y sin multiprogramación:",2,"[""Siempre mejora significativamente con la multiprogramación."",""No necesariamente mejora, pero se aprovechan mejor los recursos del sistema.""]",1,"Según la figura 2.14 del apartado 2.5.3, si bien la multiprogramación permite aprovechar mejor los recursos del sistema (CPU no ociosa), el tiempo total de ejecución de cada proceso individual puede ser mayor debido a la compartición de recursos.",dificil
"El proceso de cambio de contexto en un sistema operativo implica:",2,"[""Solo actualizar el contador de programa para apuntar al siguiente proceso."",""Guardar el estado completo del proceso saliente y restaurar el del entrante, incluyendo registros y otros datos del PCB.""]",1,"Según el apartado 2.3.3, en un cambio de contexto se guarda el estado completo del proceso saliente (registros, contador de programa, etc.) y se restaura el del proceso entrante para que pueda continuar su ejecución como si nada hubiera pasado.",dificil
"En los sistemas operativos actuales, cuando hay varios procesos en ejecución:",2,"[""Se utiliza exclusivamente paralelismo real si hay múltiples CPU o núcleos."",""Se combinan tanto pseudoparalelismo como paralelismo real.""]",1,"Según el apartado 2.1.1, en los sistemas actuales donde puede haber bastantes procesos en ejecución, encontramos tanto pseudoparalelismo como paralelismo real, ya que las CPU suelen tener varios núcleos y cada uno de ellos es utilizado por varios procesos.",dificil
"Cuando un proceso en Unix realiza una llamada al sistema execve() que tiene éxito:",2,"[""La llamada retorna un valor que indica el éxito de la operación."",""La llamada nunca regresa, pues todo el contenido del proceso es sustituido.""]",1,"Según el apartado 2.1.3, como todo el contenido del proceso que realiza la llamada a execve() se sustituye por uno nuevo, una llamada que tenga éxito nunca regresará.",dificil
"En la planificación de procesos, las metas de 'minimizar el tiempo de respuesta' y 'minimizar el tiempo de regreso':",2,"[""Son complementarias y pueden optimizarse simultáneamente."",""Son contradictorias y optimizar una generalmente perjudica a la otra.""]",1,"Según el apartado 2.5.1, hay metas contradictorias como minimizar el tiempo de respuesta para usuarios interactivos y minimizar el tiempo de regreso para trabajos por lotes. Cualquier algoritmo que favorece a un tipo de tareas perjudica a tareas de otros tipos.",dificil
"En el algoritmo de planificación FCFS (First-Come, First-Served), el tiempo promedio de respuesta:",2,"[""Es siempre el óptimo (mínimo) independientemente del orden de llegada de los procesos."",""Puede variar considerablemente dependiendo de los tiempos de ráfaga de CPU de los procesos.""]",1,"Según el apartado 2.5.4, el tiempo promedio de respuesta producido por FCFS no es mínimo y puede variar bastante si los tiempos de ráfagas de CPU de los procesos son muy distintos, como se muestra en el ejemplo de los tres procesos P1, P2, P3.",dificil
"El tratamiento de señales en Unix cuando un proceso ejecuta execve():",2,"[""Se mantiene intacto, incluyendo las señales capturadas."",""Las señales que se ignoren seguirán ignorándose, pero las que se capturen dejarán de estarlo.""]",1,"Según el apartado 2.1.3, cuando se ejecuta execve(), las señales que se ignoren seguirán ignorándose, pero las señales que se capturen dejarán de estarlo, ya que desaparece el código que tenían asociado.",dificil